* Overview
The idea is that every build takes place in a cabal sandbox.

We ultimately want to create a derivation that has been parameterized
by a set of constraints. We obtain the right constraints by running
=cabal install --dependencies-only --dry-run= on the downstream
package we are trying to build, then using that build plan to
constraint the solver when building each upstream package. The
=buildplan= file becomes part of the nix derivation of the upstream
package, meaning we can have multiple instances of the same version of
a package that have been built with different dependencies.

Those very specific derivations go into the Nix store so that they
might be re-used when the same specific instance of a package version
is again required.

** Installation
The ~cabbage~ script is tangled from this file. Put it on your ~PATH~,
or invoke it however you prefer. It is a regular bash script that
calls out to ~sed~, ~awk~, ~grep~, etc.

** Development Workflow
Run ~cabbage~ in your project's root directory (containing the
project's ~.cabal~ file). Then run,

#+BEGIN_SRC sh
nix-shell --command 'sh $setup'
#+END_SRC

to make sure all dependencies are built and linked into your
sandbox. At this point, you can ~cabal configure~ etc., outside of
~nix-shell~ and work as usual.

To build the current package with Nix, use ~cabbage -b~ instead of
~nix-build shell.nix~. The former is a short wrapper around the
latter. It simply runs ~cabal configure~ and ~cabal sdist~ before
calling ~nix-build shell.nix~.

*** Test and Benchmark Suites
If you have benchmark or test suites, you will want to run ~cabbage
-a~ to indicate that /all/ targets should be considered when gathering
dependencies.

*** System dependencies
It will take some work to alias names in a Cabal package's
~extra-libraries~ field to Nix package names. For the time being, you
can use a ~cabbage.config~ file in your project directory to specify
~systemDeps~ for each package. These will be propagated to downstream
dependencies so that they will be available in the build
environment. This part of a ~cabbage.config~ file looks like this,

#+BEGIN_EXAMPLE
systemDeps:
  mypkg: foo bar
#+END_EXAMPLE

This says that ~foo~ and ~bar~ should be listed in the ~buildInputs~
field of ~mypkg~ and everything that depends on it. The names ~foo~
and ~bar~ are resolved in the ~nixpkgs~ scope.

A real example is for the ~zlib~ package that requires the nixpkgs
package named ~zlib~. The repetition is a bit confusing, but remember
that the keys here are Cabal packages, while the values are Nix
packages.

#+BEGIN_EXAMPLE
systemDeps:
  zlib: zlib
#+END_EXAMPLE

This says that the Haskell package ~zlib~ (the one to the left of the
colon) depends upon the Nix package ~zlib~ that we get from
nixpkgs. Every Cabal package that depends on the Haskell ~zlib~
package will have the Nix ~zlib~ package in its build environment.

*** Flags
If there are flags that should be set for the package you are building
or any of its dependencies, you can create a file ~cabbage.config~
that looks like this,

#+BEGIN_EXAMPLE
flags:
  MyPackage: demos -silly
  transformers-compat: three
#+END_EXAMPLE

This file will cause dependencies in your project guarded by the
~demos~ flag to be pulled in, while the negative setting of ~silly~
will cause Cabal to treat that flag as ~False~. Assuming that
~transformers-compat~ is a transitive dependency of this package, it
will be built with the ~three~ flag which is needed when your project
ultimately must build against ~transformers < 4~.

*** Using ~nix-build~
Rather than use the entire source directory as the source of the Nix
package, cabbage uses a Cabal sdist as the source of the Nix package
when building an unpacked Cabal package. This means that Nix doesn't
waste time hashing data files or other junk you may have in your
project directory. The upshot is that you *must* run ~cabal sdist~
before running ~nix-build shell.nix~. If you do so, you should get an
executable in ~result/bin~ as usual for Nix.

** Working with other packages
You can also pass ~cabbage~ a path to a ~.cabal~ file or give it the
name of a package on [[http://hackage.haskell.org][hackage]] (which itself may have a version
suffix). In this case, ~cabbage~ will do its work in a temporary
directory. The side effect of building a named package is that the
package and all its dependencies will now exist in your Nix store so
that subsequent builds may make use of them.

Another use of this named installation interface is to install
executables. To link the executables (e.g. [[http://hackage.haskell.org/package/pandoc][pandoc]]) built from a
package into your environment, follow the instructions given in the
last line of ~cabbage~ output after running ~cabbage pandoc~. It will
give you a ~nix-env -i~ invocation that points to where ~pandoc~ has
been built in your Nix store so that it gets linked into your
environment.

* Shebang
Put a shebang line at the top of our tangled program.
#+BEGIN_SRC sh :tangle cabbage :shebang "#!/usr/bin/env bash" :padline no
#+END_SRC

* Cabal file helpers
Tooling for working with .cabal files.

#+NAME: cabalHelpers
#+BEGIN_SRC sh :exports code :tangle cabbage

cabalFileExists() {
  local NUMCABALS=$(find . -maxdepth 1 -name '?*.cabal' | wc -l)
  if [ "$NUMCABALS" -gt 1 ]; then
    return 2
  elif [ "$NUMCABALS" -eq 1 ]; then
    return 0
  else
    return 1
  fi
}

# Print only the library target portion of a .cabal file and filter
# out line comments.
isolateLibraryTarget() {
  sed -n '/^[Ll]ibrary/,/^[^[:space:]]/ { /^[[Ll]ibrary/p; /^[[:space:]]/p; }' \
  | sed 's/--.*$//'
}

# Remove any Cabal block guarded by an "if os(windows)" or "if
# os(solaris)" or "if os(ios)" conditional. This is a very fragile
# test!
removeWindowsBlocks() {
  local AWK
  read -r -d '' AWK<<'EOF'
BEGIN { windowsIndent = 0; }
{
  if(match($0, /if os\(windows\)/)) {
    windowsIndent = RSTART;
  } else if(match($0, /if os\(solaris\)/)) {
    windowsIndent = RSTART;
  } else if(match($0, /if os\(ios\)/)) {
    windowsIndent = RSTART;
  } else if(windowsIndent > 0) {
    match($0, /^[[:space:]]*/);
    if(RLENGTH <= windowsIndent) {
      windowsIndent = 0;
      print($0);
    }
  } else {
    print($0);
  }
}
EOF
  awk "$AWK"
}

# Print the library target of any .cabal file in the current directory
# while removing any blocks guarded by a windows or solaris check.
cabalLibraryTarget() {
  if cabalFileExists ; then
    cat ./*.cabal | sed 's/--.*$//' | isolateLibraryTarget | removeWindowsBlocks
  fi
}

# Take all lines until the next Cabal file stanza begins. The
# assumption is that the first line is the beginning of a stanza, so
# its indentation level determines where the next stanza begins.
stanzaHead() {
  local AWK
  read -r -d '' AWK<<'EOF'
BEGIN { firstLine = 1; }
{
  if(firstLine) {
    match($0, /^[[:space:]]*/);
    stanzaIndent = RLENGTH;
    print $0;
    firstLine = 0;
  } else {
    match($0, /^[[:space:]]*/);
    if(RLENGTH <= stanzaIndent) {
      exit;
    } else {
      print $0;
    }
  }
}
EOF
  awk "$AWK"
  
}
#+END_SRC

** pkgconfig-depends
#+NAME: pkgconfig
#+BEGIN_SRC sh :tangle cabbage :exports code
# Print out a .cabal file starting with a pkgconfig-depends line.
pkgconfigDependsStarts() {
  cat ./*.cabal | sed 's/--.*$//' | sed -n '/[[:space:]]*[Pp]kg[Cc]onfig-[Dd]epends:/,$ p'
}

# Pull all pkgconfig dependencies from a .cabal file
pkgconfigDepends() {
  if cabalFileExists ; then
    grep -q -i "[[:space:]]*pkgconfig\-depends:" *.cabal
    if [ $? -eq 0 ]; then
      pkgconfigDependsStarts | stanzaHead \
 | sed -e 's/[Pp]kg[Cc]onfig-[Dd]epends:[[:space:]]*//' -e 's/,/\
 /g' | sed 's/^[[:space:]]*//' | sed '/^$/d'
    else
      echo
    fi
  fi
}
#+END_SRC

*** pkgconfig test
#+BEGIN_SRC sh :results output :noweb yes
<<cabalHelpers>>
<<pkgconfig>>
cd ../ffmpeg-light
pkgconfigDepends
PKGS=($(pkgconfigDepends))
echo "There are ${#PKGS[@]} pkg deps"
#+END_SRC

#+RESULTS:
: libavutil
: libavformat
: libavcodec
: libswscale
: There are 4 pkg deps

** Build-tools
Pick out all build-tools used by a package and all of its dependencies.

#+NAME: allBuildTools
#+BEGIN_SRC sh :tangle cabbage :exports code

# Print each build-tool without any version constraint.
cabalBuildTools() {
  if cabalFileExists ; then
    grep -q -i "[[:space:]]*build-tools:" ./*.cabal
    if [ $? -eq 0 ]; then
      cat ./*.cabal | sed 's/--.*$//' | removeWindowsBlocks \
    | grep -i "build-tools" | awk 'BEGIN { FS=":"; } { print($2); }' | sed 's/,/\
/g' | sed -e 's/^[[:space:]]*//' -e 's/ .*$//'
    else
     echo
    fi
  fi
}

allBuildToolsAux() {
  cabalBuildTools
  if [ -d .cabbages ]; then
    local DEPS=($(buildplanDependencies))
    local d
    (cd .cabbages && \
     for d in "${DEPS[@]}"; do
       (cd "$d" &&  cabalBuildTools)
     done)
  fi
}

# Print the array of all build-tools used to build this package and
# all its dependencies.
allBuildTools() {
  local TOOLS=($(allBuildToolsAux | sort -u)) 

  # hsc2hs comes with GHC
  local special
  for special in hsc2hs ghc; do
    local i=$(findIndex "$special" TOOLS[@])
    if [ "$i" -gt -1 ]; then
      unset TOOLS[$i]
    fi
  done
  echo "${TOOLS[@]}"
}
#+END_SRC

*** Test
#+BEGIN_SRC sh :noweb yes :results output
<<cabalHelpers>>
<<findIndex>>
<<allExtraLibraries>>
<<allBuildTools>>
#cd ~/temp/rifactor
cd ~/temp/OpenCL-1.0.3.4
#cd ../Frames
#cd ../Hocl-OpenCL
allBuildTools
#+END_SRC

#+RESULTS:
: 

** Frameworks
We can pick out frameworks requirements that are needed on OS X (darwin).

#+NAME: cabalFrameworks
#+BEGIN_SRC sh :exports code :tangle cabbage
cabalFrameworks() {
  if cabalFileExists ; then
    grep -q -i "[[:space:]]*frameworks:" ./*.cabal
    if [ $? -eq 0 ]; then
      cabalLibraryTarget \
  | grep -i "frameworks" | awk 'BEGIN { FS=":"; } { print($2); }' | sed 's/,/\
/' | sort -u
    fi
  fi
}
#+END_SRC

** cabal install --dependencies-only --dry-run
Rather than using =cabal-freeze=, we can run =cabal install
--dependencies-only --dry-run= in a fresh sandbox to obtain a list of
all dependencies not available in the global database.

#+NAME: dryDependencies
#+BEGIN_SRC sh : exports code :tangle cabbage

# Prints out lines of the form "pkgName X.Y.Z" (where X, Y, and Z are
# numbers). One line for each package that will have to be installed
# in a sandbox given the current version of GHC and the contents of
# its global package database.
dryDependencies() {
  local EXTRAS=""
  if [ "$#" -gt 0 ]; then
    if [ $1 -eq 2 ]; then
      EXTRAS="--enable-tests --enable-benchmarks"
    fi
  fi
  if [ -f cabbage.config ]; then
    local MYNAME=$(cat ./*.cabal | grep -i "name:" | awk 'BEGIN { FS=":"; } {print($2);}' | sed 's/^[[:space:]]*//')
    local FLAGS=$(cat cabbage.config | flagsFor "$MYNAME")
    if ! [ "$FLAGS" = "" ]; then
      EXTRAS="$EXTRAS --flags=\"$FLAGS\""
    fi
  fi
  local CMD="cabal install --dependencies-only --dry-run"
  if ! [ "$EXTRAS" = "" ]; then
    CMD="$CMD $EXTRAS"
  fi
  eval $CMD \
| sed -n '3,$ p'  | sed '/Warning: /,$ d' \
| sed -e 's/ .*$//' -e 's/\([-_[:alnum:]]*\)-\([[:digit:].]*\)$/\1 \2/' \
| sed '/^[-_[:alnum:]]* [[:digit:]]/ !d'
}

# Reads the buildplan file in the current directory and prints one
# package per line in the form "pkgname-X.Y.Z".
buildplanDependencies() {
  if [ -f buildplan ]; then
    cat buildplan | sed 's/\([^ ]*\) \(.*\)$/\1-\2/'
  else
    echo "No buildplan found in $(pwd)"
    exit 1
  fi
}

# Generate cabal.config contents from a buildplan. This removes
# cabbage-patched version numbers so that "cabal install" can work
# properly.
buildplanConstraints() {
  echo "constraints:"; (cat buildplan | sed 's/^\([^ ]*\) \(.*\)$/  \1 ==\2,/' | sed 's/\.4552,$/,/' | sed '$ s/,//')
}
#+END_SRC

*** Test
#+BEGIN_SRC sh :noweb yes :results output
<<dryDependencies>>
<<flagsFor>>
#cd ../GLUtil
#cd CabbageDown2
cd ../Frames
dryDependencies
#+END_SRC

#+RESULTS:
#+begin_example
Boolean 0.2.3
NumInstances 1.4
OneTuple 0.2.1
abstract-par 0.3.3
ansi-terminal 0.6.2.1
ansi-wl-pprint 0.6.7.2
base-prelude 0.1.16
base64-bytestring 1.0.0.1
cereal 0.4.1.1
clock 0.4.1.3
colour 2.3.3
data-default-class 0.0.1
data-default-instances-base 0.0.1
data-default-instances-containers 0.0.1
data-default-instances-old-locale 0.0.1
digest 0.0.1.2
dlist 0.7.1.1
data-default-instances-dlist 0.0.1
data-default 0.5.3
erf 2.0.0.0
fingertree 0.1.0.1
groups 0.4.0.0
network 2.6.0.2
newtype 0.2
parallel 3.2.0.6
prelude-extras 0.4
primitive 0.5.4.0
random 1.1
abstract-deque 0.3
reflection 1.5.1.2
split 0.2.2
stm 2.4.4
syb 0.4.4
tagged 0.7.3
text 1.2.0.4
blaze-builder 0.3.3.4
blaze-markup 0.6.3.0
cookie 0.4.1.4
hashable 1.2.3.2
case-insensitive 1.2.0.4
http-types 0.8.6
mime-types 0.1.0.6
nats 1
readable 0.3.1
scientific 0.3.3.8
attoparsec 0.12.1.3
transformers 0.4.3.0
StateVar 1.1.0.0
lens-family-core 1.2.0
mmorph 1.0.4
mtl 2.2.1
blaze-svg 0.3.4.1
monad-par-extras 0.3.3
operational 0.2.3.2
parsec 3.1.9
network-uri 2.6.0.1
pipes 4.1.4
statestack 0.2.0.3
transformers-compat 0.4.0.4
distributive 0.4.4
exceptions 0.8.0.2
intervals 0.7.1
optparse-applicative 0.11.0.2
transformers-base 0.4.4
monad-control 1.0.0.4
list-t 0.4.3
tuple 0.3.0.2
unordered-containers 0.2.5.1
semigroups 0.16.2.2
utf8-string 1
publicsuffixlist 0.1
vector 0.10.12.2
FontyFruity 0.5
aeson 0.8.0.2
foldl 1.0.8
mwc-random 0.13.3.0
monad-par 0.3.4.7
vector-algorithms 0.6.0.3
vector-binary-instances 0.2.1.0
vector-th-unbox 0.2.1.2
math-functions 0.1.5.2
statistics 0.13.2.3
vinyl 0.5.1
void 0.7
MemoTrie 0.6.2
contravariant 1.3.1
comonad 4.2.5
semigroupoids 4.3
bifunctors 4.2.1
monoid-extras 0.3.3.5
dual-tree 0.2.0.5
profunctors 4.4.1
free 4.11
lens 4.7
Chart 1.3.3
vector-space 0.9
active 0.1.0.18
vector-space-points 0.2.1
diagrams-core 1.2.0.5
xml 1.3.14
zlib 0.5.4.2
JuicyPixels 3.2.3
Rasterific 0.5.1
diagrams-lib 1.2.0.8
SVGFonts 1.4.0.3
diagrams-postscript 1.1.0.4
diagrams-rasterific 0.1.0.7
diagrams-svg 1.1.0.4
Chart-diagrams 1.3.3
streaming-commons 0.1.10.0
http-client 0.4.9
zip-archive 0.2.3.7
#+end_example


#+BEGIN_SRC sh :noweb yes :results output
<<dryDependencies>>
cd CabbageDown2
dryDependencies > buildplan
DEPS=($(buildplanDependencies))
echo "We have ${#DEPS[@]} dependencies: ${DEPS[@]}"
#+END_SRC

#+RESULTS:
: We have 3 dependencies: colour-2.3.3 unix-2.7.1.0 directory-1.2.1.0

** Unconstrained
As a last-ditch effort to freeze a build plan, we can remove all
version constraints. This is needed for the hsc2hs build too.

#+NAME: unconstrained
#+BEGIN_SRC sh :exports code :tangle cabbage
unconstrainCabal() {
  local UNCONSTRAIN
  read -r -d '' UNCONSTRAIN<<'EOF'
BEGIN { 
  buildDep = 0;
  FS = ",";
}
{
  lineSkip = 0;
  if(match($0, /^[[:space:]]*[Bb][Uu][Ii][Ll][Dd]-[Dd][Ee][Pp][Ee][Nn][Dd][Ss]:/)) {
    buildDep = 1;
    match($0, /^[[:space:]]*/);
    indentation = RLENGTH;
    for(i = 0; i < RLENGTH; ++i) printf(" ");
    printf("build-depends:");
    sub(/^[[:space:]]*[Bb][Uu][Ii][Ll][Dd]-[Dd][Ee][Pp][Ee][Nn][Dd][Ss]:/,"",$0);
    match($0, /^[[:space:]]*/);
    for(i = 0; i < RLENGTH; ++i) printf(" ");
    sub(/^[[:space:]]*/,"",$0);
  } else if(buildDep) {
    if(match($0,/^[[:space:]]*$/)) {
      lineSkip = 1;
    } else {
      match($0, /^[[:space:]]*/);
      if(RLENGTH <= indentation) {
        buildDep = 0;
      } else {
        for(i = 0; i < RLENGTH; ++i) printf(" ");
        sub(/^[[:space:]]*/,"",$0);
      }
    }
  }
  if(buildDep && !lineSkip) {
    # Update a line of a build-depend
    for(i = 1; i <= NF; ++i) {
      sub(/^[[:space:]]*/,"",$(i));
      sub(/[[:space:]]*$/,"",$(i));
      if(match($(i), "[ ><=]")) {
        pkgName = substr($(i), 1, RSTART - 1);
        printf("%s", pkgName);
      } else {
        printf("%s", $(i));
      }
      if(i < NF) printf(", ");
    }
    printf("\n");
  } else {
    # Everything else gets printed
    print $0
  }
}
EOF
  awk "$UNCONSTRAIN"
}

# Try freezing after removing all version constraints.
freezeUnconstrained() {
 local NUMCABALS=$(find . -maxdepth 1 -name '?*.cabal' | wc -l)
  if [ "$NUMCABALS" -gt 1 ]; then
    echo "Error: Found multiple cabal files in $(pwd)"
    exit 1
  fi
  local REALCABAL=$(basename "$(ls ./*.cabal)")
  (cat "$REALCABAL" | sed 's/--.*$//' | unconstrainCabal) > cabbageDummy.cabal
  mv "$REALCABAL" cabbageBackup.bak
  mv cabbageDummy.cabal "$REALCABAL"
  freezeCabbagePatch 1
  local OK=$?
  return $OK
}
#+END_SRC

* Finding dependencies
So we've got a package and we've created a sandbox. We can run
=dryDependencies= to get a =buildplan= file that lists all
dependencies.

** add-sourced dependencies

Deal with the output of =cabal sandbox list-sources=. The add-sourced
directories are found between a pair of blank lines. This bit of =sed=
pulls out the directory names.

#+NAME: getAddedSources
#+BEGIN_SRC sh :tangle cabbage :exports code

# List directories of added sources
getAddedSources() {
  sed '1,/^$/ d' | sed '/^$/,$ d'
}
#+END_SRC

*** Quick test
#+BEGIN_SRC sh :result output :exports none :noweb yes
<<getAddedSources>>
IFS='' read -r -d '' LISTED <<'EOF'
Source dependencies registered in the current sandbox
('/Users/acowley/Documents/Projects/Nix/CabbageDown/.cabal-sandbox'):

/Users/acowley/Documents/Projects/Nix/TestCabbage

To unregister source dependencies, use the 'sandbox delete-source' command.
EOF

echo "$LISTED" | getAddedSources
#+END_SRC

#+RESULTS:
: /Users/acowley/Documents/Projects/Nix/TestCabbage

** Dependencies on hackage
This is just =cabal get=. We then need to =cabal configure= and
=dryDependencies= so that we can do the =buildplan= intersection
with the downstream constraints file.

However, we will also add-source everything that is add-sourced to the
downstream package before configuring.

* =cabal.config= Intersection
We want to take the version constraints from a downstream constraints
file, and merge them into an upstream constraints file.

There are two approaches to doing this:

1. Freeze downstream and upstream independently, then intersect the
   constraints
2. Freeze downstream, then edit the upstream package's ~.cabal~ file
   to replace all version constraints with equality constraints
   gleaned from the downstream ~cabal.config~ file

A problem with the first option is that sometimes Cabal's solver is
able to find a build plan for a downstream package while it is unable
to find a plan for an upstream dependency. This is rather odd, but it
happens. Another problem is that it is a bit slow, and feels somewhat
redundant since the downstream freeze fixes all the versions, the
upstream freeze is only used to get the transitive closure of the set
of dependencies of the upstream package. This is just a limitation of
what ~cabal-install~ offers.

The second option is not great as it doesn't take into account further
upstream dependencies that are constrained by other dependencies of
the downstream package. It also requires careful surgery of the rather
complicated ~.cabal~ file format. We must preserve any logic expressed
therein so that freezing the newly constrained ~.cabal~ file may rely
on that logic.

** A dummy Cabal Library

#+NAME: dummyCabalLibrary
#+BEGIN_SRC sh :tangle cabbage :exports code

# The start of a Cabal library specification, ready for a
# build-depends stanza.
dummyCabalLibrary() {
  echo "name:               Dummy"
  echo "version:            0.1.0.0"
  echo "build-type:         Simple"
  echo "cabal-version:      >=1.10"
  echo ""
  echo "library"
  echo "  exposed-modules:"
}
#+END_SRC

* Time stamps
Add-sourced dependencies are tracked with a time stamp that cabal uses
to see if they have changed since they were last built. We want to
work with this mechanism since when we build an add-sourced
dependency, we grab the latest source available. Unfortunately, this
involves some amount of parsing.

We need to be able to fill in timestamps for a GHC that is not present
in the current set of timestamps. We also need to be able to overwrite
old timestamps for the GHC we are using. Through this, we should
preserve timestamps for any /other/ GHC to be nice to the user.

We don't tangle this block as it actually gets included in the =setup=
attribute of the generated nix expression.

#+NAME: updateTimeStamps
#+BEGIN_SRC sh :exports none

# Takes a GHC platform string, an array of add-source dependency
# directories, and a string of old timestamps. Produces a new
# timestamp string.
updateTimeStamps() {
  local -a DEPS=("''\${!2}")
  local CUR_TIME=\$(date +%s)
  local i
  local STAMPED
  for ((i = 0; i < "''\${#DEPS[@]}"; ++i)); do
    STAMPED[\$i]="(\"''\${DEPS[\$i]}\",\$CUR_TIME)"
  done
  local LIST=\$(printf ",%s" "''\${STAMPED[@]}")
  LIST=''\${LIST:1}
  local NEWSTAMP="(\"\$1\",[\$LIST])"
  if echo "\$3" | grep -q "\$1"; then
    echo "\$3" | sed "s:(\"\$1\",[^]]*\]):\$NEWSTAMP:"
  elif echo "\$3" | grep -q "]\\\\$"; then
    echo "\$3" | sed "s:\]\\\$:,\$NEWSTAMP]:"
  else
    echo "[\$NEWSTAMP]"
  fi
}
#+END_SRC

** Unescaped

The above code is a bit gnarly to escape things so that it can be
tangled into a bash block and then properly escaped for a Nix expression.

#+NAME: updateTimeStamps2
#+BEGIN_SRC sh :exports none

# Takes a GHC platform string, an array of add-source dependency
# directories, and a string of old timestamps. Produces a new
# timestamp string.
updateTimeStamps() {
  local -a DEPS=("${!2}")
  local CUR_TIME=$(date +%s)
  local i
  local STAMPED
  for ((i = 0; i < "${#DEPS[@]}"; ++i)); do
    STAMPED[$i]="(\"${DEPS[$i]}\",$CUR_TIME)"
  done
  local LIST=$(printf ",%s" "${STAMPED[@]}")
  LIST=${LIST:1}
  local NEWSTAMP="(\"$1\",[$LIST])"
  if echo "$3" | grep -q "$1"; then
    echo "$3" | sed "s:(\"$1\",[^]]*\]):$NEWSTAMP:"
  else
    echo "$3" | sed "s:\]$:$NEWSTAMP]:"
  fi
}
#+END_SRC

** Tests
Test that we can append the new time stamps to an empty list, and
replace old timestamps for the correct GHC version in a populated list.

#+BEGIN_SRC sh :noweb yes :results output :exports none
<<updateTimeStamps2>>
ghcPlatform="x86_64-osx-ghc-7.8.4"
deps=("/A/B/C" "/Foo/Bar Me/Baz")
oldStampsEmpty="[]"
oldStampsPop="[(\"x86_64-osx-ghc-7.8.3\", [(\"/A/B/C\", 42)]),\
(\"x86_64-osx-ghc-7.8.4\", [(\"/A/B/C\", 42),(\"/Foo/Bar/Baz\", 42)])]"

updateTimeStamps "$ghcPlatform" deps[@] "$oldStampsEmpty"
updateTimeStamps "$ghcPlatform" deps[@] "$oldStampsPop"
#+END_SRC

#+RESULTS:
: [("x86_64-osx-ghc-7.8.4",[("/A/B/C",1425593674),("/Foo/Bar Me/Baz",1425593674)])]
: [("x86_64-osx-ghc-7.8.3", [("/A/B/C", 42)]),("x86_64-osx-ghc-7.8.4",[("/A/B/C",1425593674),("/Foo/Bar Me/Baz",1425593674)])]

* cabbage.config
** System dependencies
Concatenate all ~extra-libraries~ fields in a build plan. This is a
very rough listing as it simply filters out blocks of Cabal files
guarded behind one of "if os(windows)", "os(solaris)", or "os(ios)".

#+NAME: allExtraLibraries
#+BEGIN_SRC sh :exports code :tangle cabbage

# Prints the extra-libraires from a cabal file iff they occur in a
# library target.
cabalExtraLibraries() {
  if cabalFileExists ; then
    grep -q -i "[[:space:]]*extra\-libraries:" ./*.cabal
    if [ $? -eq 0 ]; then
      cat ./*.cabal | isolateLibraryTarget | removeWindowsBlocks | \
      grep -i "extra-libraries" | awk 'BEGIN { FS=":"; } { print($2); }'
    fi
  fi
}

# Looks in a cabal.config file to identify all dependencies, then
# visits each of them in the .cabbages directory and prints out all
# extra-libraries.
allExtraLibrariesAux() {
  local DEPS=($(buildplanDependencies))
  local d
  cabalExtraLibraries
  (cd .cabbages && \
   for d in "${DEPS[@]}"; do
     (cd "$d" &&  cabalExtraLibraries)
   done)
}

# Print out an array of possibly-needed extra-libraries.
allExtraLibraries() {
  local LIBS=($(allExtraLibrariesAux | sed 's/,/\
/'))
  if [ "${#LIBS[@]}" -gt 0 ]; then
    printf '%s\n' "${LIBS[@]}" | sort -u | tr '\n' ' '
  else
    echo "${LIBS[@]}"
  fi
}

# Let the user know they might need to prepare system dependencies.
warnExtraLibraries() {
  local LIBS=($(allExtraLibraries))
  if [ "${#LIBS[@]}" -gt 0 ]; then
    echo
    echo "You may need to supply system dependencies!"
    echo
    echo "See the cabbage documentation for how to do this with a 'systemDeps'"
    echo "section in a cabbage.config file."
    echo
    echo "Potentially necessary extra-libraries: ${LIBS[@]}"
    read -p "Press any key to continue..." -n 1 -t 5
    echo
  fi
}
#+END_SRC

*** Test
#+BEGIN_SRC sh :noweb yes :results output
<<cabalHelpers>>
<<allExtraLibraries>>
cd ~/temp/rifactor
allExtraLibraries
#+END_SRC

#+RESULTS:
: z

** Configuration lookup
We support setting project-wide flags in a ~cabbage.config~ file that
looks somewhat like a ~cabal.config~ file.

#+NAME: flagsFor
#+BEGIN_SRC sh :tangle cabbage :exports code

# Unversion package name. Remove the version number from a versioned
# package name.
unversionPackageName() {
  sed 's/\(.*\)-[-[:digit:].]*$/\1/' <<< "$1"
}

# Returns any flags set for the given package name in a cabbage.config
# file
flagsFor() {
  local FINDFLAGS
  read -r -d '' FINDFLAGS<<EOF
BEGIN { inFlags = 0; }
/^flags:/ { inFlags = 1; }
/^[^[:space:]]/ { if(inFlags == 2) { exit 0; } }
{
  if(inFlags == 1) {
    inFlags = 2;
  } else if(inFlags == 2) {
    gsub(/^[[:space:]]*/,"",\$1);
    if(\$1 == "$1:") {
      for(i = 2; i <= NR; ++i) {
        printf("%s", \$(i));
        if(i != NR) { printf(" "); }
      }
    }
  }
}
EOF
  awk "$FINDFLAGS"
}

# Find any systemDeps (system dependencies) specified for the named
# package in a cabbage.config file. The package name should be
# unversioned.
systemDepsFor() {
  local FINDDEPS
  read -r -d '' FINDDEPS<<EOF
BEGIN { inDeps = 0; }
/^systemDeps:/ { inDeps = 1; }
/^[^[:space:]]/ { if(inDeps == 2) { exit 0; } }
{
  if(inDeps == 1) {
    inDeps = 2;
  } else if(inDeps == 2) {
    gsub(/^[[:space:]]*/,"",\$1);
    if(\$1 == "$1:") {
      for(i = 2; i <= NR; ++i) {
        printf("%s", \$(i));
        if(i != NR) { printf(" "); }
      }
    }
  }
}
EOF
  awk "$FINDDEPS"
}
#+END_SRC

*** Test
Extract the flags for "transformers-compat".

#+BEGIN_SRC sh :noweb yes :exports none :results output
<<flagsFor>>
cd ~/temp/diagrams-lib-1.2.0.8
cat cabbage.config | flagsFor $(unversionPackageName "transformers-compat-0.4.0.4")
#+END_SRC

#+RESULTS:
: three

** Distribute flags to the targeted cabbages
Read in a ~cabbage.config~ file, and copy the relevant parts of the
file to each named dependency in the ~.cabbages~ directory.

There is only /one/ ~flags~ stanza in a ~cabbage.config~ file. Once
we've finished processing it, we can quit.

#+NAME: sowFlagsAwk
#+BEGIN_SRC awk
BEGIN { FS = ":"; inFlags = 0;}
/flags:/ { inFlags = 1; }
/^[^[:space:]]/ { if(inFlags == 2) { exit 0; } }
{
  if(inFlags == 1) {
    inFlags = 2;
  } else if(inFlags == 2) {
    gsub(/^[[:space:]]*/,"",$1);
    cmd = sprintf("find .cabbages -maxdepth 1 -name '%s-[[:digit:].]*'", $1);
    if( (cmd | getline versionedName) ) {
      flags = sprintf("flags:\n  %s:%s\n", $1, $2);
      cmd = sprintf("echo '%s' > .cabbages/$(basename \"%s\")/cabbage.config", flags, versionedName);
      system(cmd);
    } else {
      # print "Ignoring flag for unknown dependency:", $1
    }
  }
}
#+END_SRC

#+NAME: sowFlags
#+BEGIN_SRC sh :noweb yes :tangle cabbage :exports code

# Takes a cabbage.config file and distributes subset cabbage.config
# files to directories in the .cabbages directory on an as-needed
# basis. Specifically, the flags for a named package will be copied
# into a cabbage.config file in that package's directory.
sowFlags() {
  local AWK
  read -r -d '' AWK<<'EOF'
<<sowFlagsAwk>>
EOF
  awk "$AWK"
}
#+END_SRC

#+BEGIN_SRC sh :results output :noweb yes
<<sowFlags>>
cd ~/temp/diagrams-lib-1.2.0.8
cat cabbage.config | sowFlags
#+END_SRC

#+RESULTS:
: Ignoring flag for unknown dependency: flingle

* Creating a derivation for each dependency
Our derivations are actually not that complicated from a Nix
perspective because we aren't using much Nix machinery. Instead, we
create a sandbox, then manually symlink dependency artefacts into the
sandbox and let =cabal-install= invoke GHC with all the necessary path
information.

** Getting package dependency sources
We can =cabal get= things from hackage, but if a dependency has been
add-sourced, we should =cabal sdist= it.

*** Getting from hackage

#+BEGIN_SRC sh :exports none
cabal get $1 -d .cabbages
#+END_SRC

*** Getting from an add-source

#+NAME: getAddSource
#+BEGIN_SRC sh :tangle cabbage :exports code

# Get the package in this directory's full versioned name. E.g. name-x.y.z
getMyFullName() {
  local CABAL=$(ls ./*.cabal)
  { (cat "$CABAL" | tr -d '\r' | grep -i "^name:" | sed 's/^[Nn]ame:[[:space:]]*\(.*\)$/\1/');
    (cat "$CABAL" | tr -d '\r' | grep -i "^version:" | sed 's/^[Vv]ersion:[[:space:]]*\(.*\)$/\1/'); } \
  | tr '\n' '-' | sed 's/-$//'
}

# Takes a directory name, and returns the package that can be built
# from that directory.
getAddedPackageName() {
  (cd "$1" && getMyFullName)
}

# Get a source distribution of an added-source package
getAddSource() {
  local CWD=$(pwd)
  (cd "$1" && cabal sdist -v0 --output-directory="$CWD"/.cabbages/"$(getMyFullName)")
}
#+END_SRC

#+BEGIN_SRC sh :exports none :noweb yes :results output
<<getAddSource>>
(cd "CabbageDown" && getAddSource "../TestCabbage")
#+END_SRC

*** Get /Any/ Dependency Source
We need a helper function that can get the source code of a dependency
whether it has been add-sourced or it comes from hackage.

**** Array membership
Adapted from [[http://stackoverflow.com/questions/3685970/check-if-an-array-contains-a-value][this StackOverflow question]]

#+NAME: findIndex
#+BEGIN_SRC sh :exports code :tangle cabbage

# Takes an element and an array, returns -1 if the element is /not/ in
# the array; or its index if it is.
findIndex() {
  local i
  declare -a arr=("${!2}")
  for i in "${!arr[@]}"; do 
    [[ "${arr[$i]}" == "$1" ]] && echo $i && return 0; done
  echo "-1"
  return 1

  # for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
  # return 1
}
#+END_SRC

#+BEGIN_SRC sh :exports none :noweb yes :results output
<<findIndex>>
ARR=("hey" "you guys" "here I" "come")
echo $(findIndex "you guys" ARR[@])
#+END_SRC

#+RESULTS:
: 1

**** Getting add-sourced dependency package names
We use =cabal sandbox list-sources= to get the directories of added
sources, then =getAddedPackageName= to get the name+version of the
package in each directory.

#+BEGIN_SRC sh :noweb yes :exports none :results output
<<getAddedSources>>
<<getAddSource>>

LISTEDSOURCES="$(cd CabbageDown && cabal sandbox list-sources))"
ADDEDSOURCEDIRS=($(echo "$LISTEDSOURCES" | getAddedSources))

# We want the package name of each added source.
for i in "${!ADDEDSOURCEDIRS[@]}"; do
  ADDEDSOURCES[$i]=$(getAddedPackageName "${ADDEDSOURCEDIRS[$i]}")
done
echo "${ADDEDSOURCES[*]}"
#+END_SRC

#+RESULTS:
: TestCabbage-0.1.0.0 TestCabbage2-0.1.0.0

**** getDependencySources
Now we can define a function capable of getting the source for a
dependency that has been add-sourced to a sandbox /or/ that is
available from hackage via =cabal get=.

#+NAME: getDependencySources
#+BEGIN_SRC sh :exports code :tangle cabbage

# Get all dependency sources for the package in the current
# directory. This handles add-sourced dependencies, or those that
# "cabal get" can get (i.e. from hackage).
getDependencySources() {
  local ADDEDSOURCEDIRS=($(cabal sandbox list-sources | getAddedSources))
  local ADDEDSOURCEPACKAGES
  local i
  for i in "${!ADDEDSOURCEDIRS[@]}"; do
    ADDEDSOURCEPACKAGES[$i]=$(getAddedPackageName "${ADDEDSOURCEDIRS[$i]}")
  done
  local DEPS=($(buildplanDependencies))
  mkdir -p .cabbages
  local d
  for d in "${DEPS[@]}"; do
    i=$(findIndex "$d" ADDEDSOURCEPACKAGES[@])
    if [ "$i" -gt "-1" ]; then
      echo "Getting add-source dependency: $d"
      getAddSource "${ADDEDSOURCEDIRS[$i]}"
    elif [ -d .cabbages/"$d" ]; then
      echo "Using existing source dist of $d"
    elif [ "${d: -5}" == ".4552" ]; then
      echo "Cabbage patching globally installed package: $d"
      cabbagePatch "$d"
    else
      echo "Getting dependency: $d"
      cabal get "$d" -d .cabbages
    fi
  done
}
#+END_SRC

#+BEGIN_SRC sh :noweb yes :exports none :results output
<<getAddedSources>>
<<getAddSource>>
<<findIndex>>
<<getDependencySources>>
<<cabbagePatch>>

cd CabbageDown
getDependencySources
#+END_SRC

#+RESULTS:
: Getting add-source dependency: TestCabbage-0.1.0.0
: Getting dependency: colour-2.3.3
: Unpacking to .cabbages/colour-2.3.3/

** Create derivation
We basically use the template suggested by CabbageDown. The only parts
we need to fill in are the ~name~ and ~cabbageDeps~ attributes. The
former is the cabal package name prefixed with "haskell-", and the
latter are just the non-builtin dependencies that we =callPackage=
from their paths in the =.cabbages= directory.

*** Getting the package db path
We need to figure out a string like "x86_64-osx-ghc-7.8.4" that cabal
will use to store things like compiled libraries and a sandbox package
database.

#+NAME: getPackageDBPath
#+BEGIN_SRC sh :tangle cabbage :exports code
getPackageDBPath() {
  if [ -f cabal.sandbox.config ]; then
    cabal sandbox hc-pkg list | grep ".conf.d" | tail -n 1 | sed 's/.*\/\(.*\)-packages.conf.d.*/\1/'
    return 0
  else
    return 1
  fi
}
#+END_SRC

**** A quick test
If we are in a sandbox directory, we get the package db string. If
not, we get an error message.

#+BEGIN_SRC sh :exports none :results output :noweb yes
<<getPackageDBPath>>
cd CabbageDown
RES=$(getPackageDBPath)
if [ $? -eq 0 ]; then
  echo "$RES"
else
  echo "Not in a sandbox!"
fi
#+END_SRC

#+RESULTS:
: x86_64-osx-ghc-7.8.4
**** Experiments
#+BEGIN_SRC sh :exports none
cd CabbageDown
cabal sandbox hc-pkg list | grep ".conf.d" | tail -n 1 | sed 's/.*\/\(.*\)-packages.conf.d.*/\1/'
#+END_SRC

#+RESULTS:
: x86_64-osx-ghc-7.8.4

#+BEGIN_SRC sh :exports none
ghc-pkg list | grep ".conf.d" | tail -n 1 | sed 's/.*\/\(.*\)\/package.conf.d.*/\1/'
#+END_SRC

#+RESULTS:
: x86_64-darwin-7.8.3

#+BEGIN_SRC sh : exports none
#cd CabbageDown
cabal sandbox hc-pkg list > /dev/null
echo $?
#+END_SRC

#+RESULTS:
: 1


*** Dependency Nix packages

So we have a directory with a package's source code, and we have a
=buildplan= from the downstream package. The downstream package may
have already had some packages add-sourced to it, so we want to also
have those add-sources. We could either create an independent sandbox,
or use the downstream package's sandbox. Interestingly, we're only
doing this to get the benefit of the =cabal sandbox add-source=
commands, so perhaps using the downstream package's sandbox is the
right thing to do.

For the upstream package, we

- cabal sandbox init --sandbox=../.cabal.sandbox=
- cabal install --dependencies-only --dry-run
- Get dependencies by intersecting upstream's cabal.config with
  downstream's

**** A note on cabal install and custom setup scripts
Previously, the builder script in the Nix expression invoked ~cabal
install~ with various flags. This worked almost all the time, except
with custom setup programs. These work okay when built with
~cabal configure --builddir=...~, but the necessary flags don't seem
to be forwarded to the configure phase from an invocation of ~cabal
install~. So, for now we manually ~configure~, ~build~, and ~copy~.

This used to how we configured, built, and installed a package:

#+BEGIN_SRC sh :exports none
HOME=. \${cabalTmp} --builddir=\$out/dist --bindir=\$out/bin --with-gcc=\$CC install \$cabalFlags
#+END_SRC

A related issue arises when invoking ~cabal sdist~ which also builds
the setup program. Even with ~--builddir~ passed to ~cabal~, this
tries to built ~setup~ in a ~dist~ directory alongside the source
code.

This used to be an early part of the builder:

#+BEGIN_SRC sh :exports none
CWD=\$(pwd)
(cd \$src && cabal --config-file="\$CWD"/.cabal/config sdist --output-directory="\$CWD")
#+END_SRC


**** Helper

#+NAME: getSynopsis
#+BEGIN_SRC sh :exports code :tangle cabbage
getSynopsis() {
  local CABAL=$(ls ./*.cabal)
  cat "$CABAL" | sed -n '/^[Ss]ynopsis/,/^[^[:space:]]/ p' | sed '$d' \
  | sed -e 's/^[Ss]ynopsis:[[:space:]]*//' -e 's/^[[:space:]]*//' -e 's/"/\\"/g' \
  | tr '\n' ' '
}
#+END_SRC

***** Test
#+BEGIN_SRC sh :noweb yes :results output
<<getSynopsis>>
cd ~/Documents/Projects/Frames 
getSynopsis
#+END_SRC

#+RESULTS:
: Data frames For working with tabular data files 

**** The bash code

#+NAME: mkCabbage
#+BEGIN_SRC sh :exports code :tangle cabbage :noweb yes

# Define an attribute for each package. Takes an array of attribute
# names, and an array of corresponding directory names that are home
# to Nix package definitions (these are all in the .cabbages
# directory).
callCabbages() {
  local -a NAMES=("${!1}")
  local -a PKGS=("${!2}")
  local i

  for ((i = 0; i < ${#NAMES[@]}; ++i)); do
    local TOOLSARR=($(cd .cabbages/${PKGS[$i]} && allBuildTools))
    local TOOLS=""
    if [ ${#TOOLSARR[@]} -gt 0 ]; then
      TOOLS=" $(echo ${TOOLSARR[@]})"
    fi
    echo "      ${NAMES[$i]} = callPackage .cabbages/${PKGS[$i]} {"
    echo "        inherit frozenCabbages haskellBuildTools pkgs$TOOLS;"
    echo "      };"
  done
}

# Build a .nix file from a .cabal file in the current directory Takes
# the ghcPlatform string, this package's name, and whether or not this
# package should define frozenCabbages: 0 = this is an upstream
# package, 1 = this is a downstream package, 2 = this is a build-tool.
mkCabbage() {
  local NIX
  local FROZENUPSTREAM
  local FROZENDEF
  local LINKSANDBOX
  local DEPS=($(buildplanDependencies))
  local DEPNAMES=($(cat buildplan | sed 's/ .*$//'))

  if [ $3 -gt 0 ]; then
    # This is /the/ downstream package or a build-tool

    # We will need the standard callPackage function
    FROZENUPSTREAM="callPackage"

    # We will define the frozenCabbages attribute
    IFS=$'\n' read -r -d '' FROZENDEF <<EOF
frozenCabbages = rec {
$(callCabbages DEPNAMES[@] DEPS[@])
    };
EOF

    # We will seed the sandbox /in this directory/ with our
    # dependencies in the nix store so the user can continue using a
    # standard cabal workflow (e.g. tools like ghc-mod).
    mkdir -p .cabal-sandbox/lib/"$1"
    LINKSANDBOX="ln -sFf \${pkg.outPath}/.cabal-sandbox/$1-packages.conf.d/*.conf "$(pwd)"/.cabal-sandbox/$1-packages.conf.d/\n";

    # We create a dummy sdist file so that the src attribute on the
    # downstream package's nix expression is a file, even if its
    # contents are currently bogus. This is done so that Nix can
    # evaluate the expression and install dependencies, without which
    # the configure phase (run in order to produce the sdist) of the
    # downstream package can fail due to missing dependencies.
    if ! [ -d "./dist" ]; then
      mkdir dist
    fi
    if ! [ -f "./dist/$2.tar.gz" ]; then
      touch "./dist/$2.tar.gz"
    fi
  else
    # This is an upstream package (dependency)
    FROZENUPSTREAM="frozenCabbages"
  fi

  local SYNOPSIS=$(getSynopsis)
  local SYSTEMDEPS=""

  if [ -f ../../cabbage.config ]; then
    local MYNAME=$(unversionPackageName "$2")
    SYSTEMDEPS=$(cat ../../cabbage.config | systemDepsFor "$MYNAME")
  fi
  if [ -f cabbage.config ]; then
    local MYNAME=$(unversionPackageName "$2")
    SYSTEMDEPS=$(cat cabbage.config | systemDepsFor "$MYNAME")
  fi
  local PKGS=($(pkgconfigDepends))

  if [ "${#PKGS[@]}" -gt 0 ]; then
    SYSTEMDEPS="$SYSTEMDEPS pkgconfig"
  fi

  local TOOLS=($(allBuildTools))
  local TOOLSDEPS=""
  if [ "${#TOOLS[@]}" -gt 0 ]; then
    TOOLSDEPS=$(echo "${TOOLS[@]}" | awk '{for(i=1;i<=NF;i++) printf(", %s",$(i));}')
  fi

  local FRAMEWORKS=($(cabalFrameworks))
  local NIXLD
  if [ "${#FRAMEWORKS[@]}" -gt 0 ]; then
    local fw
    NIXLD="\
  NIX_LDFLAGS = lib.optionalString stdenv.isDarwin \""
    for fw in "${FRAMEWORKS[@]}"; do
      NIXLD="$NIXLD -framework $fw"
    done
    NIXLD="$NIXLD\";"
  else
    NIXLD=""
  fi

  # Now we build up the Nix expression
  IFS=$'\n' read -r -d '' NIX <<EOF
{ stdenv, lib, haskellBuildTools, pkgs$TOOLSDEPS, $FROZENUPSTREAM }:
let cabalTmp = "cabal --config-file=./.cabal/config";
    $FROZENDEF
    mkCmd = pkg: let nm = lib.strings.removePrefix "haskell-" pkg.name;
                     p = pkg.outPath;
                     pkgPath = ".cabal-sandbox/$1-packages.conf.d";
                 in ''ln -sFf \${p}/\${pkgPath}/*.conf \$out/\${pkgPath}/
                    '';
$(if [ $3 -gt 0 ]; then
    echo "    mkSetupCmd = pkg: let nm = lib.strings.removePrefix \"haskell-\" pkg.name;"
    echo "                          p = pkg.outPath;"
    echo "                      in \"$LINKSANDBOX\";"
  fi)
in
stdenv.mkDerivation rec {
  name = "haskell-$2";
  src = $(if [ $3 -eq 1 ]; then 
            echo "./dist/$2.tar.gz"
          else
            echo "./."
          fi);
  cabbageDeps = with frozenCabbages; [ $(echo "${DEPNAMES[@]}") ];
  systemDeps = (with pkgs; [ $SYSTEMDEPS ]) ++
               lib.lists.unique (lib.concatMap (lib.attrByPath ["systemDeps"] []) cabbageDeps);
  propagatedBuildInputs = systemDeps;$NIXLD
  buildInputs = [ stdenv.cc $(echo "${TOOLS[@]}")] ++ haskellBuildTools ++ cabbageDeps ++ systemDeps;

  # Build the commands to merge package databases
  cmds = lib.strings.concatStrings (map mkCmd cabbageDeps);
$(if [ $3 -gt 0 ]; then
    cat << SETUPEOF
  setupCmds = lib.strings.concatStrings (map mkSetupCmd cabbageDeps);
  setup = builtins.toFile "setup.sh" ''
    <<updateTimeStamps>>
    eval "\$setupCmds"
    \${cabalTmp} sandbox hc-pkg recache
    SRCS=(\$(cabal sandbox list-sources | sed '1,/^\$/ d' | sed '/^\$/,\$ d'))
    OLDTIMESTAMPS=\$(cat .cabal-sandbox/add-source-timestamps)
    updateTimeStamps "$1" SRCS[@] "\$OLDTIMESTAMPS" > .cabal-sandbox/add-source-timestamps
  '';
SETUPEOF
  fi)

  builder = builtins.toFile "builder.sh" ''
    source \$stdenv/setup
    mkdir \$out

    if [ -d "\$src" ]; then
      cp -R "\$src"/* .
      #*/
      if [ -f \$src/buildplan ]; then
        mkdir \$out/.cabbageCache
        cp "\$src/buildplan" "\$out/.cabbageCache/buildplan"
      fi
    else
      tar xf "\$src" --strip=1
    fi

    chmod -R u+w .
    if [ -d dist ]; then
      # Copy pre-generated dist files to store
      cp -R dist \$out
    fi
    \${cabalTmp} sandbox --sandbox=\$out/.cabal-sandbox init -v0
    mkdir -p \$out/.cabal-sandbox/lib/$1
    eval "\$cmds"
    \${cabalTmp} sandbox hc-pkg recache

    \${cabalTmp} --builddir=\$out/dist --bindir=\$out/bin --libdir=\$out/.cabal-sandbox/lib --with-gcc=\$CC configure \$(echo \$NIX_LDFLAGS | awk -e '{ for(i=1;i <= NF; i++) { if(match(\$(i), /^-L/)) printf("--extra-lib-dirs=%s ", substr(\$(i),3)); } }')
    echo "Building..."
    \${cabalTmp} --builddir=\$out/dist build -v0
    \${cabalTmp} --builddir=\$out/dist copy
    \${cabalTmp} --builddir=\$out/dist register
    \${cabalTmp} --builddir=\$out/dist clean || true
  '';    
  meta = {
    description = "$SYNOPSIS";
  };
}
EOF

  echo "$NIX" > default.nix
}

# Freezes the cabal file in the current directory. Takes the versioned
# name of the package to prepare, and the dbPath for the current
# platform (e.g. x86_64-osx-ghc-7.8.4).
prepCabbage() {
  local d="$1"
  local dbPath="$2"
  local FLAGS
  cabal sandbox init --sandbox=../../.cabal-sandbox > /dev/null

  if [ -f cabal.config ]; then
    mv cabal.config cabal.config.bak
  fi

  ln -s ../../bpconstraints cabal.config

  if [ -n "$FLAGS" ]; then
    freezeCabbagePatch 0 > /dev/null
  else
    freezeCabbagePatch > /dev/null
  fi

  rm cabal.config
  if [ -f cabal.config.bak ]; then
    mv cabal.config.bak cabal.config
  fi

  rm cabal.sandbox.config
  mkCabbage "$dbPath" "$d" 0
}

# Takes a flag to determine if the dependencies of all targets should
# be built. If the flag is true, then the build-depends of all targets
# are consolidated and considered when determining a build plan. The
# second argument is another flag for which true indicates this is a
# downstream package, and false indicates this is a build-tool.
mkCabbages() {
  local NUMCABALS=$(find . -maxdepth 1 -name '?*.cabal' | wc -l)
  if [ "$NUMCABALS" -gt 1 ]; then
    echo "Error: Found multiple cabal files in $(pwd)!"
    exit 1
  fi

  if [ "$1" = true ]; then
    freezeCabbagePatch 2
  else
    freezeCabbagePatch 1
    if ! [ $? -eq 0 ]; then
      if [ "$2" = false ]; then
        echo "Trying emergency constraint patch..."
        freezeUnconstrained
      fi
    fi
  fi
  if [ -f "$CABAL.cabbage.bak" ]; then
    mv "$CABAL.cabbage.bak" "$CABAL"
  fi
  local RES=$?
  if [ $RES -ne 0 ]; then
    echo "Freezing the downstream package $(pwd) failed ($RES)" && false
  else
    echo "Froze downstream package at $(pwd)"
  fi
  local dbPath=$(getPackageDBPath)
  local deps=($(buildplanDependencies))
  getDependencySources
  if [ -f cabbage.config ]; then
    cat cabbage.config | sowFlags
  fi

  # Print a message if there are extra-libraries sepecified in any
  # .cabal file used to build the downstream package that is not
  # obviously guarded by an os(windows) or os(solaris) check.
  warnExtraLibraries

  # Build a constraints file the upstream packages can use when
  # computing their own build plans.
  buildplanConstraints > bpconstraints

  pushd .cabbages > /dev/null
  local d
  for d in "${deps[@]}"; do
    echo "Making cabbage: $d"
    if [ -f "$d"/default.nix ]; then
      echo "Using existing default.nix"
    else
      (cd "$d" && prepCabbage "$d" "$dbPath")
    fi
  done
  popd > /dev/null
  rm bpconstraints

  local BUILDTOOLS=($(allBuildTools))

  if [ "${#BUILDTOOLS}" -gt 0 ]; then
    echo "Making cabbages for build-tools"
    pushd .cabbages > /dev/null
    local bt
    for bt in "${BUILDTOOLS[@]}"; do
      cabal get "$bt"
      if ! [ $? -eq 0 ]; then
        local ANS
        read -p "cabal get did not unpack $bt, should we continue? [Y/n]" -n 1 -t 5 ANS
        echo
        if [ "$ANS" = "n" ]; then
          exit 1
        fi
      fi
      local d=$(basename $(find . -name "$bt-[[:digit:].]*" -depth 1))
      echo "Making build-tool cabbage: $d"
      (cd "$d" && cabal sandbox init && mkCabbages false false)
    done
    popd > /dev/null
  fi
  
  if [ "$2" = true ]; then
    mkCabbage "$dbPath" "$(getMyFullName)" 1
  else
    mkCabbage "$dbPath" "$(getMyFullName)" 2
  fi
}
#+END_SRC

#+BEGIN_SRC sh :exports none :results output :noweb yes
<<getPackageDBPath>>
<<mkCabbage>>
<<getAddedSources>>
<<getAddSource>>
<<findIndex>>
<<getDependencySources>>
<<dummyCabalLibrary>>
<<cabbagePatch>>

(cd CabbageDown && mkCabbages)
#+END_SRC

#+RESULTS:
: Resolving dependencies...
: Froze downstream package at /Users/acowley/Documents/Projects/Cabbage/CabbageDown
: Getting add-source dependency: TestCabbage-0.1.0.0
: Using existing source dist of colour-2.3.3
: Making cabbage: TestCabbage-0.1.0.0
: Preparing /Users/acowley/Documents/Projects/Cabbage/CabbageDown/.cabbages/TestCabbage-0.1.0.0
: Resolving dependencies...
: Making cabbage: colour-2.3.3
: Preparing /Users/acowley/Documents/Projects/Cabbage/CabbageDown/.cabbages/colour-2.3.3

* Shadowing the global package database
A problem occurs when we want to rebuild a globally installed package
with different dependencies. This would leave us with two packages of
the same name and version.

There are some limitations to passing GHC packages that have identical
names and versions to ones that are installed in the global package
database. Namely, even if you pass the ~-hide-all-packages~ to GHC,
then supply it packages with the ~-package-id~ flag, a globally
installed package with the same name and version as one given via
~-package-id~ can interfere with the build. To combat this, we create
"cabbage-patched" versions of globally-installed packages.

We do this by copying the package source for the globally-installed
package, and appending 4552 to the version number (the PLU code for
Napa Cabbage). We then tweak every frozen build plan that refers to
the globally-installed package to instead refer to the cabbage-patched
version.

#+NAME: cabbagePatch
#+BEGIN_SRC sh :tangle cabbage :exports code

# Takes a cabbage-patched versioned package name; prepares an sdist.
cabbagePatch() {
  if ! [ ${1: -5} = ".4552" ]; then
    echo "Bad call to cabbagePatch with $1"
    exit 1
  fi
  local NAME=${1%".4552"}
  cabal get "$NAME" -d .cabbages
  (cd .cabbages && \
   mv "$NAME" "$1" && \
   (cd "$1" && \
    local CABAL=$(basename "$(ls ./*.cabal)") && \
     mv "$CABAL" "$CABAL".bak && \
     sed 's/\([Vv]ersion:[[:space:]]*\)\([[:digit:].]*\)$/\1\2.4552/' "$CABAL".bak > "$CABAL" && \
     rm "$CABAL".bak))
}

# Determines if a newer version of a globally installed package is
# required. If so, the exit code is 1. If no globally-installed
# package is to be upgraded, the exit code is 0.
upgradesGlobal() {
  local AWK
  read -r -d '' AWK<<'EOF'
BEGIN {
  firstLine = 1;
}
{
  if(firstLine) {
    split($0,arr," ");
    for(i in arr) {
      match(arr[i], /-[[:digit:].]*$/);
      pkg = substr(arr[i], 1, RSTART-1);
      ver = substr(arr[i],RSTART+1);
      globallyInstalled[pkg] = ver;
    }
    firstLine = 0;
  } else {
    if($1 in globallyInstalled) {
      if(globallyInstalled[$1] != $2) {
        printf("%s-%s is an upgrade from the global package database\n", $1, $2);
        exit 1;
      }
    }
  }
}
EOF
  awk "$AWK"
}

# Tweaks the constraints in a piped ~buildplan~ file to replace
# globally installed packages with cabbage patched versions.
cabbagePatchConfig() {
  local AWK
  read -r -d '' AWK<<'EOF'
BEGIN { firstLine = 1; }
{
  if(firstLine) {
    split($0,arr," ");
    for(i in arr) {
      globallyInstalled[arr[i]] = 1;
    }
    firstLine = 0;
  } else {
    versioned = sprintf("%s-%s", $1, $2);
    if(versioned in globallyInstalled) {
      printf("%s %s.4552\n", $1, $2);
    } else {
      print($0);
    }
  }
}
EOF
  awk "$AWK"
}

# Print the list of globally installed packages that can be
# reinstalled.
getReinstallableGlobals() {
  sed -e 's/base-[[:digit:].]*//' \
      -e 's/bin-package-db-[[:digit:].]*//' \
      -e 's/rts-[[:digit:].]*//' \
      -e 's/ghc-[[:digit:].]*//' \
      -e 's/ghc-prim-[[:digit:].]*//' \
      -e 's/integer-gmp-[[:digit:].]*//' | \
  sed 's/  [ ]*/ /'
}

# Find a build plan, then tweak the ~buildplan~ file to
# cabbage patch references to globally installed packages. If an
# argument is given, we do /not/ search for a cached build plan. This
# is useful when passing cabbage the "-a" flag, which will produce a
# different build plan than when this package is built as a dependency
# of something else.
freezeCabbagePatch() {
  if [ "$#" -gt 0 ]; then
    dryDependencies "$1" > buildplan
    if [ $1 -gt 0 ]; then
      # If a globally-installed package must be upgraded, then we cabbage
      # patch the build plan to allow us to shadow globally-installed
      # packages. Otherwise, we do not mention globally-installed packages
      # in the Nix build plan as GHC will pull them in by default.
      local GLOBALS=$(ghc-pkg list --global --simple-output)
      (echo "$GLOBALS"; cat buildplan) | upgradesGlobal
      if [ $? -eq 1 ]; then
        mv buildplan buildplan.bak
        (((echo "$GLOBALS" | getReinstallableGlobals); cat buildplan.bak) | cabbagePatchConfig) > buildplan
        rm buildplan.bak
      fi
    fi
  else
    dryDependencies > buildplan
  fi
}
#+END_SRC

** Notes on Globally Installed Packages

If a globally-installed package is to be upgraded, we cabbage patch
/all/ upgradeable globally-installed packages so that they can have
alternate build plans. If /no/ globally-installed package is to be
upgraded, we do not cabbage patch, and in fact remove
globally-installed packages from the downstream package's constraints
list. This lets us build things that depend upon GHC as a library, as
well as things that want to update packages that GHC itself depends
on.

* Top-level

** Default nix expression
We currently build with GHC-7.8.4 and cabal-install-1.20.0.6.

This expression is suitable for ~nix-shell~ or to be installed itself.

#+NAME: defaultShell
#+BEGIN_SRC sh

# A default Nix expression suitable for nix-shell or installation.
defaultShell() {
  local TOOLS=($(allBuildTools))

  local t
  local TOREMOVE=()
  for t in "${TOOLS[@]}"; do
    local dirname=$(find .cabbages -name "$t-[[:digit:].]*" -depth 1)
    if [ -z "$dirname" ]; then
      TOREMOVE+=($t)
    elif [ "$dirname" = "" ]; then
      TOREMOVE+=($t)
    fi
  done
  for t in "${TOREMOVE[@]}"; do
    local i=$(findIndex "$t" TOOLS[@])
    unset TOOLS[$i]
  done

  local TOOLSDEPS
  if [ "${#TOOLS[@]}" -gt 0 ]; then
    TOOLSDEPS=$(echo " ${TOOLS[@]}")
  else
    TOOLSDEPS=""
  fi
  local NIX
  IFS=$'\n' read -r -d '' NIX <<EOF
let pkgs = import <nixpkgs> {};
    mynix = import <mynix>;
    haskellBuildTools = with mynix; [ ghcDefault cabalDefault ];
$(if [ "${#TOOLS[@]}" -gt 0 ]; then
    local t
    for t in "${TOOLS[@]}"; do
      local buildTool=$(basename $(find .cabbages -name "$t-[[:digit:].]*" -depth 1))
      echo "    $t = pkgs.callPackage .cabbages/$buildTool/default.nix {"
      echo "      inherit pkgs haskellBuildTools;"
      echo "    };"
    done
  fi)
in pkgs.callPackage ./default.nix {
   inherit pkgs haskellBuildTools $(echo "${TOOLS[@]}");
}
EOF
  echo "$NIX"
}

getNamedCabbage() {
  local NIX
  read -r -d '' NIX<<EOF
with import <nixpkgs> {};
with import ./shell.nix;
(lib.findFirst (pkg: (builtins.parseDrvName pkg.name).name == "haskell-$1")
               {name="Error";}
               cabbageDeps).outPath
EOF
  echo "$NIX" > getNamedCabbage.nix

  local CABBAGE
  CABBAGE=$(nix-instantiate --eval getNamedCabbage.nix | sed 's/^"\(.*\)"$/\1/')
  echo "To install $1 in your environment, run:"
  echo "nix-env -i $CABBAGE"
}
#+END_SRC

** Arguments
If given an argument, try to get it from hackage.

The technique for creating a temporary directory that works on both
Linux and Darwin is from [[http://unix.stackexchange.com/questions/30091/fix-or-alternative-for-mktemp-in-os-x][here]].

#+NAME: buildInTempDir
#+BEGIN_SRC sh
mytmpdir=$(mktemp -d 2>/dev/null || mktemp -d -t 'cabbage-temp')
(cd "$mytmpdir" \
    && getCabalFile "$1" \
    && cabal sandbox init \
    && mkCabbages $ALLTARGETS true \
    && defaultShell > shell.nix \
    && cabal sandbox hc-pkg recache \
    && nix-shell --command "echo 'Done'" \
    && getNamedCabbage "$1")
rm -r "$mytmpdir"
#+END_SRC

*** Support to generate a dependency
When the user wants to install a library into the nix store, we
generate a dummy package that depends on the package the user wants,
then install the dummy package's dependencies with ~nix-shell~. The
cabbage process is driven by ~cabal freeze~ which is happy to run the
solver on a very minimal cabal file. So, we see what we got from
~cabal get~, then reformat the directory name into a version
constraint that we use to populate the dummy cabal file.

#+NAME: mkDummyCabal
#+BEGIN_SRC sh :exports code

# Takes a versioned file name, e.g. "foo-0.8.2",
# and returns "foo ==0.8.2"
mkConstraintString() {
  sed 's/\(.*\)-\([[:digit:]].*\)/\1 ==\2/' <<< "$1"
}

# Takes a versioned file name and produces a minimal cabal file for
# freezing purposes.
mkDummyCabal() {
  local CABAL
  local SELFDEP=$(mkConstraintString "$1")

  read -r -d '' CABAL<<EOF
name:               Dummy
version:            0.1.0.0
build-type:         Simple
cabal-version:      >=1.10

library
  build-depends:    $SELFDEP
  exposed-modules:
EOF

  echo "$CABAL"
}
#+END_SRC

**** A quick test
#+BEGIN_SRC sh :results output :exports none :noweb yes
<<mkDummyCabal>>
mkDummyCabal "foo-0.8.2"
#+END_SRC

#+RESULTS:
: cabal-version:      >=1.10
: 
: executable Dummy
:   build-depends:    foo ==0.8.2

*** Getting the file to build in a temporary directory
#+NAME: getCabalFile
#+BEGIN_SRC sh :noweb yes :exports code
<<mkDummyCabal>>

# If the argument is a cabal file, copy the contents of the directory
# it is in to the current directory. Otherwise, try using ~cabal get~
# to download the package from hackage.
getCabalFile() {
  if [ -f "$1" ]; then
    cp -R "$(dirname "$1")"/* .
  else
    mkdir -p .cabbages
    cabal get "$1" -d .cabbages
    local VERSIONED_NAME=$(ls .cabbages)
    mkDummyCabal "$VERSIONED_NAME" > dummy.cabal
  fi
}
#+END_SRC

** No arguments
This lets us just run the tangled shell script from the command line
and generates a Nix expression for the cabal file in the current
directory.

** Code
#+BEGIN_SRC sh :exports code :tangle cabbage :noweb yes
<<getCabalFile>>
<<defaultShell>>

showHelp() {
  echo "Usage: cabbage [-a] [-b] [packageName]"
  echo ""
  echo "- Run cabbage in a directory with a .cabal file to build Nix"
  echo "  expressions for the current package and all of its dependencies."
  echo "  Then run 'nix-shell --run 'sh $setup'' to ensure that all "
  echo "  dependencies are available in the Nix store, and to link them into "
  echo "  the sandbox. "
  echo "  If no sandbox is in the current directory, a new one will be created."
  echo ""
  echo "- The '-a' option will additionally link the dependencies of any "
  echo "  benchmark and test suites. "
  echo ""
  echo "- The '-b' option will build the project with nix-build."
  echo ""
  echo "- If cabbage is given a path to a .cabal file or a package name "
  echo "  (with optional version suffix) available on hackage, that package "
  echo "  will be built in a temporary directory so that it is available in "
  echo "  the Nix store for future builds. If you want executables provided "
  echo "  by that package to be linked into your environment, follow the "
  echo "  instructions in the last line of cabbage output."
}

ALLTARGETS=false

while getopts ":abh" opt; do
  case "$opt" in
    a) ALLTARGETS=true;;
    b) cabal configure && cabal sdist -v0 && nix-build shell.nix; exit 0;;
    h|\?) showHelp; exit 0;;
  esac
done
shift $((OPTIND - 1))

if [ "$#" -eq 0 ]; then
  if ! [ -f cabal.sandbox.config ]; then
    cabal sandbox init
  fi
  mkCabbages $ALLTARGETS true
  if ! [ -f shell.nix ]; then
    defaultShell > shell.nix
  fi
else
  <<buildInTempDir>>
fi
#+END_SRC

* Tasks
** TODO Cache cabbages
Right now, we always download a package and we always generate a
cabbage. What we could do is cache the downloaded source /and/ the
result of ~cabal freeze~, then do the buildplan intersection and
check if we've got an equivalent default.nix in the cache. It's not
clear how much time this would save. We need to do the constraint
intersection no matter what. We could hash the constraint intersection
with the package's .cabal file and see if we've already generated an
equivalent cabbage. This would just save us the trouble of producing
the actual .nix files, but much of the work would have already been
done.
** TODO systemDeps for common packages
We could define a Nix expression that has ~systemDeps~ for a bunch of
well-known Haskell packages. This could serve to obviate the need for
a ~cabbage.config~ specification of ~systemDeps~ for common
packages. Where would we install this expression?
** TODO Automatic extra-libraries parsing
A Haskell package like ~zlib~ has an ~extra-libraries~ field that
mentions ~z~. This system dependency, ~libz~, is provided by the
nixpkgs package, ~zlib~. It would be nice to parse these out of .cabal
files automatically and map them to nixpkgs package names. In the
meantime, these can be manually specified a ~cabbage.config~ file.
