* Overview
The idea is that every build takes place in a cabal sandbox.

We ultimately want to create a derivation that has been parameterized
by a set of constraints. We obtain the right constraints by running
=cabal freeze= on the downstream package we are trying to build, then
intersecting the result of =cabal freeze= run against each upstream
package with that original constraints file. The smaller constraints
file becomes part of the nix derivation of the upstream package,
meaning we can have multiple instances of the same version of a
package that have been built with different dependencies.

Those very specific derivations go into the Nix store so that they
might be re-used when the same specific instance of a package version
is again required.

** Installation
The ~cabbage~ script is tangled from this file. Make it executable and
put it on your ~PATH~, or invoke it however you prefer. It is a
regular bash script that calls out to ~sed~, ~awk~, ~grep~, etc.

** Development Workflow
Run ~cabbage~ in your project's root directory (containing the
project's ~.cabal~ file). Then run,

#+BEGIN_SRC sh
nix-shell --command 'sh $setup'
#+END_SRC

to make sure all dependencies are built and linked into your
sandbox. At this point, you can ~cabal configure~ etc., outside of
~nix-shell~ and work as usual.

If the above ~nix-shell~ command gives you an error (e.g. with Nix
1.8), you can try running ~nix-shell~ without any arguments, then,
once in the shell, run, 

#+BEGIN_SRC sh
sh "$setup"
#+END_SRC


To build the current package with Nix, use ~cabbage -b~ instead of
~nix-build shell.nix~. The former is a short wrapper around the
latter. It simply runs ~cabal configure~ and ~cabal sdist~ before
calling ~nix-build shell.nix~.

*** Test and Benchmark Suites
If you have benchmark or test suites, you will want to run ~cabbage
-a~ to indicate that /all/ targets should be considered when gathering
dependencies.

*** System dependencies
It will take some work to alias names in a Cabal package's
~extra-libraries~ field to Nix package names. For the time being, you
can use a ~cabbage.config~ file in your project directory to specify
~systemDeps~ for each package. These will be propagated to downstream
dependencies so that they will be available in the build
environment. This part of a ~cabbage.config~ file looks like this,

#+BEGIN_EXAMPLE
systemDeps:
  mypkg: foo bar
#+END_EXAMPLE

This says that ~foo~ and ~bar~ should be listed in the ~buildInputs~
field of ~mypkg~ and everything that depends on it. The names ~foo~
and ~bar~ are resolved in the ~nixpkgs~ scope.

A real example is for the ~zlib~ package that requires the nixpkgs
package named ~zlib~. The repetition is a bit confusing, but remember
that the keys here are Cabal packages, while the values are Nix
packages.

#+BEGIN_EXAMPLE
systemDeps:
  zlib: zlib
#+END_EXAMPLE

This says that the Haskell package ~zlib~ (the one to the left of the
colon) depends upon the Nix package ~zlib~ that we get from
nixpkgs. Every Cabal package that depends on the Haskell ~zlib~
package will have the Nix ~zlib~ package in its build environment.

*** Flags
If there are flags that should be set for the package you are building
or any of its dependencies, you can create a file ~cabbage.config~
that looks like this,

#+BEGIN_EXAMPLE
flags:
  MyPackage: demos -silly
  transformers-compat: three
#+END_EXAMPLE

This file will cause dependencies in your project guarded by the
~demos~ flag to be pulled in, while the negative setting of ~silly~
will cause Cabal to treat that flag as ~False~. Assuming that
~transformers-compat~ is a transitive dependency of this package, it
will be built with the ~three~ flag which is needed when your project
ultimately must build against ~transformers < 4~.

** Working with other packages
You can also pass ~cabbage~ a path to a ~.cabal~ file or give it the
name of a package on [[http://hackage.haskell.org][hackage]] (which itself may have a version
suffix). In this case, ~cabbage~ will do its work in a temporary
directory. The side effect of building a named package is that the
package and all its dependencies will now exist in your Nix store so
that subsequent builds may make use of them.

Another use of this named installation interface is to install
executables. To link the executables (e.g. [[http://hackage.haskell.org/package/pandoc][pandoc]]) built from a
package into your environment, follow the instructions given in the
last line of ~cabbage~ output after running ~cabbage pandoc~. It will
give you a ~nix-env -i~ invocation that points to where ~pandoc~ has
been built in your Nix store so that it gets linked into your
environment.

* Shebang
Put a shebang line at the top of our tangled program.

#+BEGIN_SRC sh :tangle cabbage :padline no
#!/usr/bin/env bash
#+END_SRC

* Finding dependencies
So we've got a package and we've created a sandbox. We can run =cabal
freeze= to get a =cabal.config= file that lists all dependencies.

** add-sourced dependencies

Deal with the output of =cabal sandbox list-sources=. The add-sourced
directories are found between a pair of blank lines. This bit of =sed=
pulls out the directory names.

#+NAME: getAddedSources
#+BEGIN_SRC sh :tangle cabbage :exports code

# List directories of added sources
getAddedSources() {
  sed '1,/^$/ d' | sed '/^$/,$ d'
}
#+END_SRC

*** Quick test
#+BEGIN_SRC sh :result output :exports none :noweb yes
<<getAddedSources>>
IFS='' read -r -d '' LISTED <<'EOF'
Source dependencies registered in the current sandbox
('/Users/acowley/Documents/Projects/Nix/CabbageDown/.cabal-sandbox'):

/Users/acowley/Documents/Projects/Nix/TestCabbage

To unregister source dependencies, use the 'sandbox delete-source' command.
EOF

echo "$LISTED" | getAddedSources
#+END_SRC

#+RESULTS:
: /Users/acowley/Documents/Projects/Nix/TestCabbage

** Dependencies on hackage
This is just =cabal get=. We then need to =cabal configure= and =cabal
freeze= so that we can do the =cabal.config= intersection with the
downstream constraints file.

However, we will also add-source everything that is add-sourced to the
downstream package before configuring.

* =cabal.config= Intersection
We want to take the version constraints from a downstream constraints
file, and merge them into an upstream constraints file.

There are two approaches to doing this:

1. Freeze downstream and upstream independently, then intersect the
   constraints
2. Freeze downstream, then edit the upstream package's ~.cabal~ file
   to replace all version constraints with equality constraints
   gleaned from the downstream ~cabal.config~ file

A problem with the first option is that sometimes Cabal's solver is
able to find a build plan for a downstream package while it is unable
to find a plan for an upstream dependency. This is rather odd, but it
happens. Another problem is that it is a bit slow, and feels somewhat
redundant since the downstream freeze fixes all the versions, the
upstream freeze is only used to get the transitive closure of the set
of dependencies of the upstream package. This is just a limitation of
what ~cabal-install~ offers.

The second option is not great as it doesn't take into account further
upstream dependencies that are constrained by other dependencies of
the downstream package. It also requires careful surgery of the rather
complicated ~.cabal~ file format. We must preserve any logic expressed
therein so that freezing the newly constrained ~.cabal~ file may rely
on that logic.

** Independent freezing
The ~cabal freeze~ command is rather underfeatured: it does not
support supplying extra constraints or flags for dependencies. This
can prevent it from finding build plans when we artificially constraint the
~.cabal~ file with constraints from a downstream package. Another
approach is to ~cabal freeze~ the upstream package on its own, then
intersect that ~cabal.config~ file with the one from downstream.

*** AWK constraint intersection
#+NAME: awkConstraintIntersection
#+BEGIN_SRC sh :exports code

# Takes two sets of constraints separates by a line containing only
# "***" and returns the second set of package names with versions
# drawn from the first set.
awkConstraintIntersection() {
  read -r -d '' intersect<<'EOF'
BEGIN {
  downConfig = 1;
  numUpstream = 0;
}
{ 
  if($1 == "***") {
    downConfig = 0;
  } else if(downConfig) {
    downstream[$1] = $2;
  } else {
    numUpstream++;
    upstream[$1] = downstream[$1];
  }
}
END {
  cnt = 0;
  for (p in upstream) {
    if(cnt==0) {
      printf("constraints: ");
    } else {
      printf("             ");
    }
    printf("%s ==%s", p, upstream[p]);
    cnt++;
    if(cnt != numUpstream) { printf(",\n"); }
  }
}
EOF
awk "$intersect"
# <<< $(cat $1 - $2 <<< "***")
}
#+END_SRC

**** Intersection tests
Quick test

#+BEGIN_SRC sh :results output :noweb yes
<<awkConstraintIntersection>>
read -r -d '' config1<<'EOF'
foo 0.1.2
bar 2.1.3
baz 4.1
EOF

read -r -d '' config2<<'EOF'
foo 0.1
baz 5.2
EOF

BOTH=$(printf "%s\n***\n%s" "$config1" "$config2")
RES=$(awkConstraintIntersection <<< "$BOTH")
echo "$RES"

#+END_SRC

#+RESULTS:
: constraints: baz ==4.1,
:              foo ==0.1.2

*** Update Constraints AWK
#+NAME: updateConstraintsAwk
#+BEGIN_SRC sh :noweb yes :tangle cabbage
<<awkConstraintIntersection>>
<<isolateConstraints>>
 
# Takes two constraint files, downstream and upstream
updateConstraintsAwk() {
  { (isolateAndCleanupConstraints < "$1"); \
    echo "***"; \
    (isolateAndCleanupConstraints < "$2"); } \
  | awkConstraintIntersection
}
#+END_SRC

**** Test of the whole thing
#+BEGIN_SRC sh :results output :noweb yes
<<updateConstraintsAwk>>
updateConstraintsAwk experiments/a-cabal.config experiments/b-cabal.config
#+END_SRC

#+RESULTS:
: constraints: base ==4.8,
:              rts ==1.0,
:              ghc-prim ==0.3.1.0,
:              integer-gmp ==0.5.1.0

**** Big test with GLUtil
#+BEGIN_SRC sh :noweb yes :results output :exports none
<<updateConstraintsAwk>>

read -r -d '' configGLUtil<<'EOF'
constraints: GLURaw ==1.4.0.1,
             JuicyPixels ==3.1.6.1,
             OpenGL ==2.10.0.0,
             OpenGLRaw ==1.5.0.0,
             array ==0.5.0.0,
             base ==4.7.0.1,
             bytestring ==0.10.4.0,
             containers ==0.5.5.1,
             ghc-prim ==0.3.1.0,
             hashable ==1.2.2.0,
             integer-gmp ==0.5.1.0,
             text ==1.1.1.3,
             time ==1.4.2,
             transformers ==0.3.0.0,
             transformers-compat ==0.3.3.4,
             unix ==2.7.0.1,
             unordered-containers ==0.2.5.0,
             vector ==0.10.11.0,
             void ==0.6.1,
             zlib ==0.5.4.1
documentation: True
EOF

read -r -d '' configHashable<<'EOF'
constraints: array ==0.5.0.0,
             base ==4.7.0.2,
             bytestring ==0.10.4.0,
             deepseq ==1.3.0.2,
             ghc-prim ==0.3.1.0,
             integer-gmp ==0.5.1.0,
             rts ==1.0,
             text ==1.2.0.4
EOF

TMP1=$(mktemp -t 'cabbage')
TMP2=$(mktemp -t 'cabbage')
echo "$configGLUtil" > $TMP1
echo "$configHashable" > $TMP2
updateConstraintsAwk "$TMP1" "$TMP2"
rm $TMP1
rm $TMP2
#+END_SRC

#+RESULTS:
: constraints: base ==4.7.0.1,
:              text ==1.1.1.3,
:              deepseq ==1.3.0.2,
:              rts ==1.0,
:              bytestring ==0.10.4.0,
:              ghc-prim ==0.3.1.0,
:              array ==0.5.0.0,
:              integer-gmp ==0.5.1.0

** Updating build-depends constraints in-place

This approach process an entire ~.cabal~ file, leaving everything
intact except for dependency constraints that are overridden by the
~cabal.config~ generated for the downstream package.

#+NAME: pinBuildDepends
#+BEGIN_SRC sh :exports code :tangle cabbage
pinBuildDepends() {
  local PIN
  read -r -d '' PIN<<'EOF'
BEGIN { 
  downConfig = 1;
  buildDep = 0;
}
/[[:space:]]*[Bb][Uu][Ii][Ll][Dd]-[Dd][Ee][Pp][Ee][Nn][Dd][Ss]:/ {
  match($0, /^[[:space:]]*/);
  indentation = RLENGTH;
  for(i = 0; i < RLENGTH; ++i) printf(" ");
  printf("build-depends:");

  buildDep = 2;
  gsub(/^[[:space:]]*[Bb][Uu][Ii][Ll][Dd]-[Dd][Ee][Pp][Ee][Nn][Dd][Ss]:/,"",$0);
}
{
  if(downConfig && $1 == "***") {
    downConfig = 0;
    FS=",";
  } else if(downConfig) {
    downstream[$1] = $2;
  } else if(buildDep) {
    match($0, /^[[:space:]]*/);
    if(buildDep == 2 || RLENGTH > indentation) {
      buildDep = 1;
      # Update a line of a build-depend
      for(i = 1; i <= NF; ++i) {
        if(i == NF && match($(i), "^[[:space:]]*$")) {
        } else {
          if(i == 1) {
            # Add leading spaces
            match($(i), "^[[:space:]]*");
            for(j = 0; j < RLENGTH; ++j) {
              printf(" ");
            }
          }
          gsub(/^[[:space:]]*/,"",$(i));
          gsub(/[[:space:]]*$/,"",$(i));
          if(match($(i), "[ ><=]")) {
            pkgName = substr($(i), 1, RSTART - 1);
            if(pkgName in downstream) {
              printf("%s ==%s", pkgName, downstream[pkgName]);
            } else {
              printf("%s", $(i));
            }
          } else {
            if($(i) in downstream) {
              printf("%s ==%s", $(i), downstream[$(i)]);
            } else {
              printf("%s", $(i));
            }
          }
        }
        if(i < NF) printf(", ");
      }
      printf("\n");
    } else {
      # We've left a build-depends stanza
      buildDep = 0;
      print $0
    }
  } else {
    # Everything else gets printed
    print $0
  }
}
EOF
  awk "$PIN"
}
#+END_SRC

#+BEGIN_SRC sh :noweb yes :results output
<<pinBuildDepends>>
<<isolateConstraints>>

{ (isolateAndCleanupConstraints < ../Frames/cabal.config); \
  echo "***"; \
  cat ../Frames/.cabbages/hashable-1.2.3.1/hashable.cabal; } \
| pinBuildDepends

#+END_SRC

** Build-depends reformatting
We sometimes extract one or more ~build-depends~ stanzas from a
~.cabal~ file. These are comma separated, can contain line comments,
and are spaced somewhat unpredictably. This helper reformats them to
"package, constraint" format

#+NAME: buildDependsReformat
#+BEGIN_SRC sh :exports code :tangle cabbage

# Given a build-depends stanza, remove the "build-depends:" string,
# commas between dependencies, and line comments. Then, remove leading
# spaces and reformat each dependency as "package, versions".
buildDependsReformat() {
  sed -e 's/^[[:space:]]*[Bb][Uu][Ii][Ll][Dd]-[Dd][Ee][Pp][Ee][Nn][Dd][Ss]:[[:space:]]*//' -e 's/,/\
  /g' -e 's/--.*$//' | sed -e 's/^[[:space:]]*//' -e 's/ /, /' \
  -e 's/\([[:alpha:]]\)\([<>=]\)/\1, \2/'
}
#+END_SRC

** Build-depends updating
We simplify the job of ~cabal freeze~ by giving it a ~.cabal~ file
that is already loaded with the constraints of the downstream
package's ~cabal.config~ file.

** Working with ~cabal.config~ files
We first use sed to isolate the constraint lines.
#+NAME: isolateConstraints
#+BEGIN_SRC sh :exports code :tangle cabbage

# Takes a configuration file and extracts the "constraints" section.
isolateConstraints() {
  sed -n '/^[Cc]onstraints/,/^[^[:space:]]/ { /^[Cc]onstraints/p; /^[[:space:]]/p; }'
}

isolateAndCleanupConstraints() {
  isolateConstraints | sed -e 's/^constraints: //' -e 's/^[[:space:]]*//' \
  | sed 's/\([-_[:alpha:]]*\) ==\([[:digit:].]*\),*$/\1 \2/'
}
#+END_SRC

#+BEGIN_SRC sh :noweb yes :results output
<<isolateConstraints>>
cat "../GLUtil/cabal.config" | isolateAndCleanupConstraints
#+END_SRC

** A dummy Cabal Library

#+NAME: dummyCabalLibrary
#+BEGIN_SRC sh :tangle cabbage :exports code

# The start of a Cabal library specification, ready for a
# build-depends stanza.
dummyCabalLibrary() {
  echo "name:               Dummy"
  echo "version:            0.1.0.0"
  echo "build-type:         Simple"
  echo "cabal-version:      >=1.10"
  echo ""
  echo "library"
  echo "  exposed-modules:"
}
#+END_SRC

** Freezing with downstream constraints
Now we can put the constraint intersection pieces together. We take a
~cabal.config~ produced by ~cabal freeze~ run against a downstream
package and a ~.cabal~ file for an upstream package mentioned in that
~cabal.config~ file. We produce a temporary upstream package ~.cabal~
file with all versions pinned by the downstream ~cabal.config~, and
pass that to ~cabal freeze~ to obtain the upstream package's
transitive dependencies.

#+NAME: freezeWithConstraints
#+BEGIN_SRC sh :exports code :tangle cabbage

# Takes a constraints file and works with the .cabal file in the
# current directory.
freezeWithConstraints() {
  local NUMCABALS=$(find . -maxdepth 1 -name '?*.cabal' | wc -l)
  if [ "$NUMCABALS" -gt 1 ]; then
    echo "Error: Found multiple cabal files in $(pwd)"
    exit 1
  fi
  local REALCABAL=$(basename "$(ls ./*.cabal)")
  ({ (isolateAndCleanupConstraints < "$1"); echo "***"; cat "$REALCABAL"; } \
   | pinBuildDepends) > cabbageDummy.cabal
  mv "$REALCABAL" cabbageBackup.bak
  cabal freeze
  local OK=$?
  mv cabbageBackup.bak "$REALCABAL"
  rm cabbageDummy.cabal
  return $OK
}
#+END_SRC

*** Example data

#+BEGIN_SRC sh :exports none :results output :noweb yes
<<isolateConstraints>>
read -r -d '' CONFIG<<'EOF'
constraints: GLURaw ==1.4.0.1,
             JuicyPixels ==3.1.6.1,
             OpenGL ==2.10.0.0,
             OpenGLRaw ==1.5.0.0,
             zlib ==0.5.4.1
documentation: True
EOF

CLEAN=$(isolateAndCleanupConstraints <<< "$CONFIG")
echo "$CLEAN"
#+END_SRC

#+RESULTS:
: GLURaw 1.4.0.1
: JuicyPixels 3.1.6.1
: OpenGL 2.10.0.0
: OpenGLRaw 1.5.0.0
: zlib 0.5.4.1

* Time stamps
Add-sourced dependencies are tracked with a time stamp that cabal uses
to see if they have changed since they were last built. We want to
work with this mechanism since when we build an add-sourced
dependency, we grab the latest source available. Unfortunately, this
involves some amount of parsing.

We need to be able to fill in timestamps for a GHC that is not present
in the current set of timestamps. We also need to be able to overwrite
old timestamps for the GHC we are using. Through this, we should
preserve timestamps for any /other/ GHC to be nice to the user.

We don't tangle this block as it actually gets included in the =setup=
attribute of the generated nix expression.

#+NAME: updateTimeStamps
#+BEGIN_SRC sh :exports none

# Takes a GHC platform string, an array of add-source dependency
# directories, and a string of old timestamps. Produces a new
# timestamp string.
updateTimeStamps() {
  local -a DEPS=("''\${!2}")
  local CUR_TIME=\$(date +%s)
  local i
  local STAMPED
  for ((i = 0; i < "''\${#DEPS[@]}"; ++i)); do
    STAMPED[\$i]="(\"''\${DEPS[\$i]}\",\$CUR_TIME)"
  done
  local NEWSTAMP="(\"\$1\",[''\${STAMPED[@]}])"
  if echo "\$3" | grep -q "\$1"; then
    echo "\$3" | sed "s:(\"\$1\",[^]]*\]):\$NEWSTAMP:"
  else
    echo "\$3" | sed "s:\]\\\$:\$NEWSTAMP]:"
  fi
}
#+END_SRC

** Unescaped

The above code is a bit gnarly to escape things so that it can be
tangled into a bash block and then properly escaped for a Nix expression.

#+NAME: updateTimeStamps2
#+BEGIN_SRC sh :exports none

# Takes a GHC platform string, an array of add-source dependency
# directories, and a string of old timestamps. Produces a new
# timestamp string.
updateTimeStamps() {
  local -a DEPS=("${!2}")
  local CUR_TIME=\$(date +%s)
  local i
  local STAMPED
  for ((i = 0; i < "${#DEPS[@]}"; ++i)); do
    STAMPED[\$i]="(\"${DEPS[$i]}\",$CUR_TIME)"
  done
  local NEWSTAMP="(\"$1\",[${STAMPED[@]}])"
  if echo "$3" | grep -q "$1"; then
    echo "$3" | sed "s:(\"$1\",[^]]*\]):$NEWSTAMP:"
  else
    echo "$3" | sed "s:\]\$:$NEWSTAMP]:"
  fi
}
#+END_SRC

** Tests
Test that we can append the new time stamps to an empty list, and
replace old timestamps for the correct GHC version in a populated list.

#+BEGIN_SRC sh :noweb yes :results output :exports none
<<updateTimeStamps2>>
ghcPlatform="x86_64-osx-ghc-7.8.4"
deps=("/A/B/C" "/Foo/Bar Me/Baz")
oldStampsEmpty="[]"
oldStampsPop="[(\"x86_64-osx-ghc-7.8.3\", [(\"/A/B/C\", 42)]),\
(\"x86_64-osx-ghc-7.8.4\", [(\"/A/B/C\", 42),(\"/Foo/Bar/Baz\", 42)])]"

updateTimeStamps "$ghcPlatform" deps[@] "$oldStampsEmpty"
updateTimeStamps "$ghcPlatform" deps[@] "$oldStampsPop"
#+END_SRC

#+RESULTS:
: [("x86_64-osx-ghc-7.8.4",[("/A/B/C",1423839326) ("/Foo/Bar Me/Baz",1423839326)])]
: [("x86_64-osx-ghc-7.8.3", [("/A/B/C", 42)]),("x86_64-osx-ghc-7.8.4",[("/A/B/C",1423839326) ("/Foo/Bar Me/Baz",1423839326)])]

* Flag overrides
We support setting project-wide flags in a ~cabbage.config~ file that
looks somewhat like a ~cabal.config~ file.

#+NAME: flagsFor
#+BEGIN_SRC sh :tangle cabbage :exports code

# Unversion package name. Remove the version number from a versioned
# package name.
unversionPackageName() {
  sed 's/\(.*\)-[-[:digit:].]*$/\1/' <<< "$1"
}

# Returns any flags set for the given package name in a cabbage.config
# file
flagsFor() {
  local FINDFLAGS
  read -r -d '' FINDFLAGS<<EOF
BEGIN { inFlags = 0; }
/^flags:/ { inFlags = 1; }
/^[^[:space:]]/ { if(inFlags == 2) { exit 0; } }
{
  if(inFlags == 1) {
    inFlags = 2;
  } else if(inFlags == 2) {
    gsub(/^[[:space:]]*/,"",\$1);
    if(\$1 == "$1:") {
      for(i = 2; i <= NR; ++i) {
        printf("%s", \$(i));
        if(i != NR) { printf(" "); }
      }
    }
  }
}
EOF
  awk "$FINDFLAGS"
}

# Find any systemDeps (system dependencies) specified for the named
# package in a cabbage.config file. The package name should be
# unversioned.
systemDepsFor() {
  local FINDDEPS
  read -r -d '' FINDDEPS<<EOF
BEGIN { inDeps = 0; }
/^systemDeps:/ { inDeps = 1; }
/^[^[:space:]]/ { if(inDeps == 2) { exit 0; } }
{
  if(inDeps == 1) {
    inDeps = 2;
  } else if(inDeps == 2) {
    gsub(/^[[:space:]]*/,"",\$1);
    if(\$1 == "$1:") {
      for(i = 2; i <= NR; ++i) {
        printf("%s", \$(i));
        if(i != NR) { printf(" "); }
      }
    }
  }
}
EOF
  awk "$FINDDEPS"
}

# Takes a flag setting and replaces occurences of that flag in a
# .cabal file with the boolean value indicated by the argument. An
# argument of "foo" or "+foo" sets flag "foo" to "True", while "-foo"
# sets it to "False".
fixFlagValue() {
  local PAT
  local VAL
  if [ "${1:0:1}" = "+" ]; then
    PAT="flag(${1:1})"
    VAL="True"
  elif [ "${1:0:1}" = "-" ]; then
    PAT="flag(${1:1})"
    VAL="False"
  else
    PAT="flag($1)"
    VAL="True"
  fi
  sed "s/$PAT/$VAL/g"
}

# Takes a space-separated list of flag values, and fixes their
# assignments in the .cabal file in the current directory.
fixAllFlags() {
  local CABAL=$(basename "$(ls ./*.cabal)")
  local -a ARR=($1)
  for f in "${ARR[@]}"; do
    (cat "$CABAL" | fixFlagValue "$f") > "$CABAL.tmp"
    mv "$CABAL.tmp" "$CABAL"
  done
}
#+END_SRC

*** Test
Extract the flags for "transformers-compat".

#+BEGIN_SRC sh :noweb yes :exports none :results output
<<flagsFor>>
cd ~/temp/diagrams-lib-1.2.0.8
cat cabbage.config | flagsFor $(unversionPackageName "transformers-compat-0.4.0.4")
#+END_SRC

#+RESULTS:
: three

Fix multiple flags in "transformers-compat".
#+BEGIN_SRC sh :noweb yes :exports none :results output
<<flagsFor>>
cd ~/temp/diagrams-lib-1.2.0.8/.cabbages/transformers-compat-0.4.0.4
fixAllFlags "three -mtl"
#+END_SRC

** Distribute flags to the targeted cabbages
Read in a ~cabbage.config~ file, and copy the relevant parts of the
file to each named dependency in the ~.cabbages~ directory.

There is only /one/ ~flags~ stanza in a ~cabbage.config~ file. Once
we've finished processing it, we can quit.

#+NAME: sowFlagsAwk
#+BEGIN_SRC awk
BEGIN { FS = ":"; inFlags = 0;}
/flags:/ { inFlags = 1; }
/^[^[:space:]]/ { if(inFlags == 2) { exit 0; } }
{
  if(inFlags == 1) {
    inFlags = 2;
  } else if(inFlags == 2) {
    gsub(/^[[:space:]]*/,"",$1);
    cmd = sprintf("find .cabbages -maxdepth 1 -name '%s-[[:digit:].]*'", $1);
    if( (cmd | getline versionedName) ) {
      flags = sprintf("flags:\n  %s:%s\n", $1, $2);
      cmd = sprintf("echo '%s' > .cabbages/$(basename \"%s\")/cabbage.config", flags, versionedName);
      system(cmd);
    } else {
      # print "Ignoring flag for unknown dependency:", $1
    }
  }
}
#+END_SRC

#+NAME: sowFlags
#+BEGIN_SRC sh :noweb yes :tangle cabbage :exports code

# Takes a cabbage.config file and distributes subset cabbage.config
# files to directories in the .cabbages directory on an as-needed
# basis. Specifically, the flags for a named package will be copied
# into a cabbage.config file in that package's directory.
sowFlags() {
  local AWK
  read -r -d '' AWK<<'EOF'
<<sowFlagsAwk>>
EOF
  awk "$AWK"
}
#+END_SRC

#+BEGIN_SRC sh :results output :noweb yes
<<sowFlags>>
cd ~/temp/diagrams-lib-1.2.0.8
cat cabbage.config | sowFlags
#+END_SRC

#+RESULTS:
: Ignoring flag for unknown dependency: flingle

* Creating a derivation for each dependency
Our derivations are actually not that complicated from a Nix
perspective because we aren't using much Nix machinery. Instead, we
create a sandbox, then manually symlink dependency artefacts into the
sandbox and let =cabal-install= invoke GHC with all the necessary path
information.

** Getting package dependency names
List the exact package names we need as dependencies.

#+NAME: getDependencyNames
#+BEGIN_SRC sh :tangle cabbage :exports code
# Takes a constraint line, returns a package name with version
getDependency() {
   sed 's/^[Cc]onstraints://' | sed 's/^[[:space:]]*//' \
   | sed 's/\([-_[:alpha:]]*\) \([[:digit:].]*[,]*\)/\1-\2/'
}

# Remove packages that come with GHC
filterOutWiredIn() {
  grep -Ev "^(base-[[:digit:]]|bin-package-db-[[:digit:]]|rts-[[:digit:]]|ghc-[[:digit:]]|ghc-prim-[[:digit:]]\
|integer-gmp-[[:digit:]])"
}

# Takes a cabal.config file and outputs a list of package names
getDependencies() {
  (isolateAndCleanupConstraints < "$1") | getDependency | filterOutWiredIn
  if [ -f cabbage.config ]; then
    (isolateAndCleanupConstraints < cabbage.config) | getDependency | filterOutWiredIn
  fi
}

#+END_SRC

#+BEGIN_SRC sh :results output :noweb yes
<<isolateConstraints>>
<<getDependencyNames>>
cd ~/temp/rifactor
getDependencies cabal.config
#cat cabal.confg | isolateConstraints
#+END_SRC

*** Quick tests

#+BEGIN_SRC sh :noweb yes :results output :exports none
<<isolateConstraints>>
<<getDependencyNames>>
getDependencies experiments/a-cabal.config
#+END_SRC

#+RESULTS:
: TestCabbage-0.1.0.0


** Getting package dependency sources
We can =cabal get= things from hackage, but if a dependency has been
add-sourced, we should =cabal sdist= it.

*** Getting from hackage

#+BEGIN_SRC sh :exports none
cabal get $1 -d .cabbages
#+END_SRC

*** Getting from an add-source

#+NAME: getAddSource
#+BEGIN_SRC sh :tangle cabbage :exports code

# Get the package in this directory's full versioned name
getMyFullName() {
  local CABAL=$(ls ./*.cabal)
  { (cat "$CABAL" | tr -d '\r' | grep "^[Nn]ame:" | sed 's/^[Nn]ame:[[:space:]]*\(.*\)$/\1/');
    (cat "$CABAL" | tr -d '\r' | grep "^[Vv]ersion:" | sed 's/^[Vv]ersion:[[:space:]]*\(.*\)$/\1/'); } \
  | tr '\n' '-' | sed 's/-$//'
}

# Takes a directory name, and returns the package that can be built
# from that directory.
getAddedPackageName() {
  (cd "$1" && getMyFullName)
}

# Get a source distribution of an added-source package
getAddSource() {
  local CWD=$(pwd)
  (cd "$1" && cabal sdist -v0 --output-directory="$CWD"/.cabbages/"$(getMyFullName)")
}
#+END_SRC

#+BEGIN_SRC sh :exports none :noweb yes :results output
<<getAddSource>>
(cd "CabbageDown" && getAddSource "../TestCabbage")
#+END_SRC

*** Get /Any/ Dependency Source
We need a helper function that can get the source code of a dependency
whether it has been add-sourced or it comes from hackage.

**** Array membership
Adapted from [[http://stackoverflow.com/questions/3685970/check-if-an-array-contains-a-value][this StackOverflow question]]

#+NAME: findIndex
#+BEGIN_SRC sh :exports code :tangle cabbage

# Takes an element and an array, returns -1 if the element is /not/ in
# the array; or its index if it is.
findIndex() {
  local i
  declare -a arr=("${!2}")
  for i in "${!arr[@]}"; do 
    [[ "${arr[$i]}" == "$1" ]] && echo $i && return 0; done
  echo "-1"
  return 1

  # for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
  # return 1
}
#+END_SRC

#+BEGIN_SRC sh :exports none :noweb yes :results output
<<findIndex>>
ARR=("hey" "you guys" "here I" "come")
echo $(findIndex "you guys" ARR[@])
#+END_SRC

#+RESULTS:
: 1

**** Getting add-sourced dependency package names
We use =cabal sandbox list-sources= to get the directories of added
sources, then =getAddedPackageName= to get the name+version of the
package in each directory.

#+BEGIN_SRC sh :noweb yes :exports none :results output
<<getAddedSources>>
<<getAddSource>>

LISTEDSOURCES="$(cd CabbageDown && cabal sandbox list-sources))"
ADDEDSOURCEDIRS=($(echo "$LISTEDSOURCES" | getAddedSources))

# We want the package name of each added source.
for i in "${!ADDEDSOURCEDIRS[@]}"; do
  ADDEDSOURCES[$i]=$(getAddedPackageName "${ADDEDSOURCEDIRS[$i]}")
done
echo "${ADDEDSOURCES[*]}"
#+END_SRC

#+RESULTS:
: TestCabbage-0.1.0.0 TestCabbage2-0.1.0.0

**** getDependencySources
Now we can define a function capable of getting the source for a
dependency that has been add-sourced to a sandbox /or/ that is
available from hackage via =cabal get=.

#+NAME: getDependencySources
#+BEGIN_SRC sh :exports code :tangle cabbage

# Get all dependency sources for the package in the current
# directory. This handles add-sourced dependencies, or those that
# "cabal get" can get (i.e. from hackage).
getDependencySources() {
  local ADDEDSOURCEDIRS=($(cabal sandbox list-sources | getAddedSources))
  local ADDEDSOURCEPACKAGES
  local i
  for i in "${!ADDEDSOURCEDIRS[@]}"; do
    ADDEDSOURCEPACKAGES[$i]=$(getAddedPackageName "${ADDEDSOURCEDIRS[$i]}")
  done
  local DEPS=($(getDependencies cabal.config))
  mkdir -p .cabbages
  local d
  for d in "${DEPS[@]}"; do
    i=$(findIndex "$d" ADDEDSOURCEPACKAGES[@])
    if [ "$i" -gt "-1" ]; then
      echo "Getting add-source dependency: $d"
      getAddSource "${ADDEDSOURCEDIRS[$i]}"
    elif [ -d .cabbages/"$d" ]; then
      echo "Using existing source dist of $d"
    elif [ "${d: -5}" == ".4552" ]; then
      echo "Cabbage patching globally installed package: $d"
      cabbagePatch "$d"
    else
      echo "Getting dependency: $d"
      cabal get "$d" -d .cabbages
    fi
  done
}
#+END_SRC

#+BEGIN_SRC sh :noweb yes :exports none :results output
<<getDependencyNames>>
<<getAddedSources>>
<<getAddSource>>
<<findIndex>>
<<getDependencySources>>
<<cabbagePatch>>

cd CabbageDown
getDependencySources
#+END_SRC

#+RESULTS:
: Getting add-source dependency: TestCabbage-0.1.0.0
: Getting dependency: colour-2.3.3
: Unpacking to .cabbages/colour-2.3.3/

** Create derivation
We basically use the template suggested by CabbageDown. The only parts
we need to fill in are the ~name~ and ~cabbageDeps~ attributes. The
former is the cabal package name prefixed with "haskell-", and the
latter are just the non-builtin dependencies that we =callPackage=
from their paths in the =.cabbages= directory.

*** Getting the package db path
We need to figure out a string like "x86_64-osx-ghc-7.8.4" that cabal
will use to store things like compiled libraries and a sandbox package
database.

#+NAME: getPackageDBPath
#+BEGIN_SRC sh :tangle cabbage :exports code
getPackageDBPath() {
  if [ -f cabal.sandbox.config ]; then
    cabal sandbox hc-pkg list | grep ".conf.d" | tail -n 1 | sed 's/.*\/\(.*\)-packages.conf.d.*/\1/'
    return 0
  else
    return 1
  fi
}
#+END_SRC

**** A quick test
If we are in a sandbox directory, we get the package db string. If
not, we get an error message.

#+BEGIN_SRC sh :exports none :results output :noweb yes
<<getPackageDBPath>>
cd CabbageDown
RES=$(getPackageDBPath)
if [ $? -eq 0 ]; then
  echo "$RES"
else
  echo "Not in a sandbox!"
fi
#+END_SRC

#+RESULTS:
: x86_64-osx-ghc-7.8.4
**** Experiments
#+BEGIN_SRC sh :exports none
cd CabbageDown
cabal sandbox hc-pkg list | grep ".conf.d" | tail -n 1 | sed 's/.*\/\(.*\)-packages.conf.d.*/\1/'
#+END_SRC

#+RESULTS:
: x86_64-osx-ghc-7.8.4

#+BEGIN_SRC sh :exports none
ghc-pkg list | grep ".conf.d" | tail -n 1 | sed 's/.*\/\(.*\)\/package.conf.d.*/\1/'
#+END_SRC

#+RESULTS:
: x86_64-darwin-7.8.3

#+BEGIN_SRC sh : exports none
#cd CabbageDown
cabal sandbox hc-pkg list > /dev/null
echo $?
#+END_SRC

#+RESULTS:
: 1


*** Dependency Nix packages

So we have a directory with a package's source code, and we have a
=cabal.config= from the downstream package. The downstream package may
have already had some packages add-sourced to it, so we want to also
have those add-sources. We could either create an independent sandbox,
or use the downstream package's sandbox. Interestingly, we're only
doing this to get the benefit of the =cabal sandbox add-source=
commands, so perhaps using the downstream package's sandbox is the
right thing to do.

Okay, so for the upstream package, we

- cabal sandbox init --sandbox=../.cabal.sandbox=
- cabal freeze
- Get dependencies by intersecting upstream's cabal.config with
  downstream's

**** A note on cabal install and custom setup scripts
Previously, the builder script in the Nix expression invoked ~cabal
install~ with various flags. This worked almost all the time, except
with custom setup programs. These work okay when built with
~cabal configure --builddir=...~, but the necessary flags don't seem
to be forwarded to the configure phase from an invocation of ~cabal
install~. So, for now we manually ~configure~, ~build~, and ~copy~.

This used to how we configured, built, and installed a package:

#+BEGIN_SRC sh :exports none
HOME=. \${cabalTmp} --builddir=\$out/dist --bindir=\$out/bin --with-gcc=\$CC install \$cabalFlags
#+END_SRC

A related issue arises when invoking ~cabal sdist~ which also builds
the setup program. Even with ~--builddir~ passed to ~cabal~, this
tries to built ~setup~ in a ~dist~ directory alongside the source
code.

This used to be an early part of the builder:

#+BEGIN_SRC sh :exports none
CWD=\$(pwd)
(cd \$src && cabal --config-file="\$CWD"/.cabal/config sdist --output-directory="\$CWD")
#+END_SRC


**** Helper

#+NAME: getSynopsis
#+BEGIN_SRC sh :exports code :tangle cabbage
getSynopsis() {
  local CABAL=$(ls ./*.cabal)
  cat "$CABAL" | sed -n '/^[Ss]ynopsis/,/^[^[:space:]]/ p' | sed '$d' \
  | sed -e 's/^[Ss]ynopsis:[[:space:]]*//' -e 's/^[[:space:]]*//' -e 's/"/\\"/g' \
  | tr '\n' ' '
}
#+END_SRC

***** Test
#+BEGIN_SRC sh :noweb yes :results output
<<getSynopsis>>
cd ~/Documents/Projects/Frames 
getSynopsis
#+END_SRC

#+RESULTS:
: Data frames For working with tabular data files 

**** The bash code

#+NAME: mkCabbage
#+BEGIN_SRC sh :exports code :tangle cabbage :noweb yes

# Define an attribute for each package. Takes an array of attribute
# names, and an array of corresponding directory names that are home
# to Nix package definitions (these are all in the .cabbages
# directory).
callCabbages() {
  local -a NAMES=("${!1}")
  local PKGS
  local -a PKGS=("${!2}")
  local i

  for ((i = 0; i < ${#NAMES[@]}; ++i)); do
    echo "      ${NAMES[$i]} = callPackage .cabbages/${PKGS[$i]} {"
    echo "        inherit frozenCabbages haskellBuildTools pkgs;"
    echo "      };"
  done
}

# Build a .nix file from a .cabal file in the current directory Takes
# the ghcPlatform string, this package's name, and whether or not this
# package should define frozenCabbages.
mkCabbage() {
  local NIX
  local FROZENUPSTREAM
  local FROZENDEF
  local LINKSANDBOX
  local DEPS=($(getDependencies cabal.config))

  local DEPNAMES
  local i
  for ((i=0; i < ${#DEPS[@]}; ++i)); do
    # Remove version number from dependency name
    DEPNAMES[$i]=$(sed 's/\(.*\)-[[:digit:]].*/\1/' <<< "${DEPS[$i]}")
  done

  if [ "$3" = true ]; then
    # This is /the/ downstream package

    # We will need the standard callPackage function
    FROZENUPSTREAM="callPackage"

    # We will define the frozenCabbages attribute
    IFS=$'\n' read -r -d '' FROZENDEF <<EOF
frozenCabbages = rec {
$(callCabbages DEPNAMES[@] DEPS[@])
    };
EOF

    # We will seed the sandbox /in this directory/ with our
    # dependencies in the nix store so the user can continue using a
    # standard cabal workflow (e.g. tools like ghc-mod).
    mkdir -p .cabal-sandbox/lib/"$1"
    LINKSANDBOX="ln -sFf \${pkg.outPath}/.cabal-sandbox/$1-packages.conf.d/*.conf "$(pwd)"/.cabal-sandbox/$1-packages.conf.d/\n";

    # We create a dummy sdist file so that the src attribute on the
    # downstream package's nix expression is a file, even if its
    # contents are currently bogus. This is done so that Nix can
    # evaluate the expression and install dependencies, without which
    # the configure phase (run in order to produce the sdist) of the
    # downstream package can fail due to missing dependencies.
    if ! [ -d "./dist" ]; then
      mkdir dist
    fi
    if ! [ -f "./dist/$2.tar.gz" ]; then
      touch "./dist/$2.tar.gz"
    fi
  else
    # This is an upstream package (dependency)
    FROZENUPSTREAM="frozenCabbages"
  fi

  local SYNOPSIS=$(getSynopsis)
  local SYSTEMDEPS
  if [ -f ../../cabbage.config ]; then
    local MYNAME=$(unversionPackageName "$2")
    SYSTEMDEPS=$(cat ../../cabbage.config | systemDepsFor "$MYNAME")
  else
    SYSTEMDEPS=""
  fi

  # Now we build up the Nix expression
  IFS=$'\n' read -r -d '' NIX <<EOF
{ stdenv, lib, haskellBuildTools, pkgs, $FROZENUPSTREAM }:
let cabalTmp = "cabal --config-file=./.cabal/config";
    $FROZENDEF
    mkCmd = pkg: let nm = lib.strings.removePrefix "haskell-" pkg.name;
                     p = pkg.outPath;
                     pkgPath = ".cabal-sandbox/$1-packages.conf.d";
                 in ''ln -sFf \${p}/\${pkgPath}/*.conf \$out/\${pkgPath}/
                    '';
    mkSetupCmd = pkg: let nm = lib.strings.removePrefix "haskell-" pkg.name;
                          p = pkg.outPath;
                      in "$LINKSANDBOX";
in
stdenv.mkDerivation rec {
  name = "haskell-$2";
  src = $(if [ "$3" = true ]; then 
            echo "./dist/$2.tar.gz"
          else
            echo "./."
          fi);
  cabbageDeps = with frozenCabbages; [ $(echo "${DEPNAMES[@]}") ];
  systemDeps = (with pkgs; [ $SYSTEMDEPS ]) ++
               lib.lists.unique (lib.concatMap (lib.attrByPath ["systemDeps"] []) cabbageDeps);
  propagatedBuildInputs = systemDeps;
  buildInputs = [ stdenv.cc ] ++ haskellBuildTools ++ cabbageDeps ++ systemDeps;

  # Build the commands to merge package databases
  cmds = lib.strings.concatStrings (map mkCmd cabbageDeps);
  setupCmds = lib.strings.concatStrings (map mkSetupCmd cabbageDeps);

  setup = builtins.toFile "setup.sh" ''
    <<updateTimeStamps>>
    eval "\$setupCmds"
    \${cabalTmp} sandbox hc-pkg recache
    SRCS=(\$(cabal sandbox list-sources | sed '1,/^\$/ d' | sed '/^\$/,\$ d'))
    OLDTIMESTAMPS=\$(cat .cabal-sandbox/add-source-timestamps)
    updateTimeStamps "$1" SRCS[@] "\$OLDTIMESTAMPS" > .cabal-sandbox/add-source-timestamps
  '';

  builder = builtins.toFile "builder.sh" ''
    source \$stdenv/setup
    mkdir \$out

    if [ -d "\$src" ]; then
      cp -R "\$src"/* .
      #*/
    else
      tar xf "\$src" --strip=1
    fi

    chmod -R u+w .
    \${cabalTmp} sandbox --sandbox=\$out/.cabal-sandbox init -v0
    mkdir -p \$out/.cabal-sandbox/lib/$1
    eval "\$cmds"
    \${cabalTmp} sandbox hc-pkg recache

    \${cabalTmp} --builddir=\$out/dist --bindir=\$out/bin --libdir=\$out/.cabal-sandbox/lib --with-gcc=\$CC configure \$(echo \$NIX_LDFLAGS | awk -e '{ for(i=1;i <= NF; i++) { if(match(\$(i), /^-L/)) printf("--extra-lib-dirs=%s ", substr(\$(i),3)); } }')
    echo "Building..."
    \${cabalTmp} --builddir=\$out/dist build -v0
    \${cabalTmp} --builddir=\$out/dist copy
    \${cabalTmp} --builddir=\$out/dist register
    \${cabalTmp} --builddir=\$out/dist clean || true
  '';    
  meta = {
    description = "$SYNOPSIS";
  };
}
EOF

  echo "$NIX" > default.nix
}

prepCabbage() {
  if [ -f cabbage.config ]; then
    local MYNAME=$(unversionPackageName "$d")
    local FLAGS=$(cat cabbage.config | flagsFor "$MYNAME")
    if ! [ "$FLAGS" = "" ]; then
      echo "Applying flags \"$FLAGS\" to $MYNAME"
      fixAllFlags "$FLAGS"
    fi
  fi
  freezeCabbagePatch > /dev/null
  if ! [ $? -eq 0 ]; then
    freezeWithConstraints ../../cabal.config
  else
    mv cabal.config cabal.config.bak
    updateConstraintsAwk ../../cabal.config cabal.config.bak > cabal.config
  fi
  mkCabbage "$dbPath" "$d" false
}

# Takes a flag to determine if the dependencies of all targets should
# be built. If the flag is true, then the build-depends of all targets
# are consolidated and considered when determining a build plan.
mkCabbages() {
  local NUMCABALS=$(find . -maxdepth 1 -name '?*.cabal' | wc -l)
  if [ "$NUMCABALS" -gt 1 ]; then
    echo "Error: Found multiple cabal files in $(pwd)!"
    exit 1
  fi
  local CABAL=$(basename "$(ls ./*.cabal)")
  if [ -f cabbage.config ]; then
    local MYVNAME=$(getMyFullName)
    local MYNAME=$(unversionPackageName "$MYVNAME")
    local FLAGS=$(cat cabbage.config | flagsFor "$MYNAME")
    if ! [ "$FLAGS" = "" ]; then
      echo "Applying flags \"$FLAGS\" to the current project"
      cp "$CABAL" "$CABAL.cabbage.bak"
      fixAllFlags "$FLAGS"
    fi
  fi
  if [ "$1" = true ]; then
    freezeConsolidatedCabal ./*.cabal
  else
    freezeCabbagePatch
  fi
  if [ -f "$CABAL.cabbage.bak" ]; then
    mv "$CABAL.cabbage.bak" "$CABAL"
  fi
  local RES=$?
  if [ $RES -ne 0 ]; then
    echo "Freezing the downstream package $(pwd) failed ($RES)" && false
  else
    echo "Froze downstream package at $(pwd)"
  fi
  local dbPath=$(getPackageDBPath)
  local deps=($(getDependencies cabal.config))
  getDependencySources
  if [ -f cabbage.config ]; then
    cat cabbage.config | sowFlags
  fi
  pushd .cabbages > /dev/null
  for d in "${deps[@]}"; do
    echo "Making cabbage: $d"
    (cd "$d" && prepCabbage)
  done
  popd > /dev/null
  
  mkCabbage "$dbPath" "$(getMyFullName)" true
}
#+END_SRC

#+BEGIN_SRC sh :exports none :results output :noweb yes
<<getPackageDBPath>>
<<getDependencyNames>>
<<mkCabbage>>
<<getAddedSources>>
<<getAddSource>>
<<findIndex>>
<<getDependencySources>>
<<dummyCabalLibrary>>
<<isolateConstraints>>
<<buildDependsReformat>>
<<pinBuildDepends>>
<<freezeWithConstraints>>
<<updateConstraintsAwk>>
<<cabbagePatch>>

(cd CabbageDown && mkCabbages)
#+END_SRC

#+RESULTS:
: Resolving dependencies...
: Froze downstream package at /Users/acowley/Documents/Projects/Cabbage/CabbageDown
: Getting add-source dependency: TestCabbage-0.1.0.0
: Using existing source dist of colour-2.3.3
: Making cabbage: TestCabbage-0.1.0.0
: Preparing /Users/acowley/Documents/Projects/Cabbage/CabbageDown/.cabbages/TestCabbage-0.1.0.0
: Resolving dependencies...
: Making cabbage: colour-2.3.3
: Preparing /Users/acowley/Documents/Projects/Cabbage/CabbageDown/.cabbages/colour-2.3.3

* Multiple Targets

We sometimes want ~cabal freeze~ to consider the dependencies of all
targets, including test and benchmark suites. We accomplish this by
producing an alternate ~.cabal~ file where benchmark and test suites
have been changed to executable build targets, then running ~cabal
freeze~ against that.

#+NAME: testBenchExecutable
#+BEGIN_SRC sh :exports code
testBenchExecutable() {
  sed -e 's/^[Tt]est-[Ss]uite[[:space:]]*\(.*\)$/executable test-suite-\1/' \
      -e 's/^[Bb]enchmark[[:space:]]*\(.*\)$/executable benchmark-\1/' \
      -e 's/^[[:space:]]*[Tt]ype:.*$//'
}
#+END_SRC

** Consolidated Cabal

#+NAME: freezeConsolidatedCabal
#+BEGIN_SRC sh :tangle cabbage :noweb yes :exports code
<<testBenchExecutable>>

freezeConsolidatedCabal() {
  local NUMCABALS=$(find . -maxdepth 1 -name '?*.cabal' | wc -l)
  if [ "$NUMCABALS" -gt 1 ]; then
    echo "Error: Found multiple cabal files!"
    exit 1
  fi
  local REALCABAL=$(basename "$(ls ./*.cabal)")
  (cat "$REALCABAL" | testBenchExecutable) > cabbageDummy.cabal
  mv "$REALCABAL" cabbageBackup.bak
  freezeCabbagePatch
  mv cabbageBackup.bak "$REALCABAL"
  rm cabbageDummy.cabal
}
#+END_SRC

* Shadowing the global package database
A problem occurs when we want to rebuild a globally installed package
with different dependencies. This would leave us with two packages of
the same name and version.

There are some limitations to passing GHC packages that have identical
names and versions to ones that are installed in the global package
database. Namely, even if you pass the ~-hide-all-packages~ to GHC,
then supply it packages with the ~-package-id~ flag, a globally
installed package with the same name and version as one given via
~-package-id~ can interfere with the build. To combat this, we create
"cabbage-patched" versions of globally-installed packages.

We do this by copying the package source for the globally-installed
package, and appending 4552 to the version number (the PLU code for
Napa Cabbage). We then tweak every frozen build plan that refers to
the globally-installed package to instead refer to the cabbage-patched
version.

#+NAME: cabbagePatch
#+BEGIN_SRC sh :tangle cabbage :exports code

# Takes a cabbage-patched versioned package name; prepares an sdist.
cabbagePatch() {
  if ! [ ${1: -5} = ".4552" ]; then
    echo "Bad call to cabbagePatch with $1"
    exit 1
  fi
  local NAME=${1%".4552"}
  cabal get "$NAME" -d .cabbages
  (cd .cabbages && \
   mv "$NAME" "$1" && \
   (cd "$1" && \
    local CABAL=$(basename "$(ls ./*.cabal)") && \
     mv "$CABAL" "$CABAL".bak && \
     sed 's/\([Vv]ersion:[[:space:]]*\)\([[:digit:].]*\)$/\1\2.4552/' "$CABAL".bak > "$CABAL" && \
     rm "$CABAL".bak))
}

# Tweaks the constraints in a piped ~cabal.config~ file to replace
# globally installed packages with cabbage patched versions.
cabbagePatchConfig() {
  local AWK
  read -r -d '' AWK<<'EOF'
BEGIN {
  firstLine = 1;
  inConstraints = 0;
}
/^[Cc]onstraints:/ {
  inConstraints = 1;
  printf("constraints:");
  gsub(/^[Cc]onstraints:/,"",$0);
}
{
  if(firstLine) {
    split($0,arr," ");
    for(i in arr) {
      globallyInstalled[arr[i]] = 1;
    }
    firstLine = 0;
  } else if(inConstraints) {
    if(match($0, /^[[:space:]]/)) {
      inConstraints = 2;
      match($0, /^[[:space:]]*/);
      for(i = 0; i < RLENGTH; ++i) printf(" ");
      sub(/^[[:space:]]*/,"",$0);
      match($0, " ==");
      pkgName = substr($0, 1, RSTART - 1);
      versionStart = RSTART + 3;
      hasComma = 0;
      if(match($0, ",")) {
        hasComma = 1;
      }
      sub(/,/,"",$0);
      pkgVersion = substr($0, versionStart);
      versioned = sprintf("%s-%s",pkgName,pkgVersion);
      if(versioned in globallyInstalled) {
        printf("%s ==%s.4552", pkgName, pkgVersion);
      } else {
        printf("%s", $0);
      }
      if(hasComma) printf(",\n");
      else printf("\n");
    } else {
      inConstraints = 0;
      print($0);
    }
  } else {
    print($0);
  }
}
EOF
  awk "$AWK"
}

# Print the list of globally installed packages that can be
# reinstalled.
getReinstallableGlobals() {
  ghc-pkg list --global --simple-output | \
  sed -e 's/base-[[:digit:].]*//' \
      -e 's/bin-package-db-[[:digit:].]*//' \
      -e 's/rts-[[:digit:].]*//' \
      -e 's/ghc-[[:digit:].]*//' \
      -e 's/ghc-prim-[[:digit:].]*//' \
      -e 's/integer-gmp-[[:digit:].]*//' | \
  sed 's/  [ ]*/ /'
}

# Freeze a cabal package, then tweak the ~cabal.config~ file to
# cabbage patch references to globally installed packages.
freezeCabbagePatch() {
  cabal freeze
  mv cabal.config cabal.config.bak
  ((getReinstallableGlobals; cat cabal.config.bak) | cabbagePatchConfig) > cabal.config
  rm cabal.config.bak
}
#+END_SRC

* Top-level

** Default nix expression
We currently build with GHC-7.8.4 and cabal-install-1.20.0.6.

This expression is suitable for ~nix-shell~ or to be installed itself.

#+NAME: defaultShell
#+BEGIN_SRC sh

# A default Nix expression suitable for nix-shell or installation.
defaultShell() {
  local NIX
  IFS=$'\n' read -r -d '' NIX <<'EOF'
let pkgs = import <nixpkgs> {}; in
pkgs.callPackage ./default.nix {
   inherit pkgs;
   haskellBuildTools = with pkgs;
                       [ ghc.ghc784
                         haskellPackages.cabalInstall_1_20_0_6
                         haskellPackages.happy ];
}
EOF
  echo "$NIX"
}

getNamedCabbage() {
  local NIX
  read -r -d '' NIX<<EOF
with import <nixpkgs> {};
with import ./shell.nix;
(lib.findFirst (pkg: (builtins.parseDrvName pkg.name).name == "haskell-$1")
               {name="Error";}
               cabbageDeps).outPath
EOF
  echo "$NIX" > getNamedCabbage.nix

  local CABBAGE
  CABBAGE=$(nix-instantiate --eval getNamedCabbage.nix | sed 's/^"\(.*\)"$/\1/')
  echo "To install $1 in your environment, run:"
  echo "nix-env -i $CABBAGE"
}
#+END_SRC

** Arguments
If given an argument, try to get it from hackage.

The technique for creating a temporary directory that works on both
Linux and Darwin is from [[http://unix.stackexchange.com/questions/30091/fix-or-alternative-for-mktemp-in-os-x][here]].

#+NAME: buildInTempDir
#+BEGIN_SRC sh
mytmpdir=$(mktemp -d 2>/dev/null || mktemp -d -t 'cabbage-temp')
(cd "$mytmpdir" \
    && getCabalFile "$1" \
    && cabal sandbox init \
    && mkCabbages $ALLTARGETS \
    && defaultShell > shell.nix \
    && cabal sandbox hc-pkg recache \
    && nix-shell --command "echo 'Done'" \
    && getNamedCabbage "$1")
rm -r "$mytmpdir"
#+END_SRC

*** Support to generate a dependency
When the user wants to install a library into the nix store, we
generate a dummy package that depends on the package the user wants,
then install the dummy package's dependencies with ~nix-shell~. The
cabbage process is driven by ~cabal freeze~ which is happy to run the
solver on a very minimal cabal file. So, we see what we got from
~cabal get~, then reformat the directory name into a version
constraint that we use to populate the dummy cabal file.

#+NAME: mkDummyCabal
#+BEGIN_SRC sh :exports code

# Takes a versioned file name, e.g. "foo-0.8.2",
# and returns "foo ==0.8.2"
mkConstraintString() {
  sed 's/\(.*\)-\([[:digit:]].*\)/\1 ==\2/' <<< "$1"
}

# Takes a versioned file name and produces a minimal cabal file for
# freezing purposes.
mkDummyCabal() {
  local CABAL
  local SELFDEP=$(mkConstraintString "$1")

  read -r -d '' CABAL<<EOF
name:               Dummy
version:            0.1.0.0
build-type:         Simple
cabal-version:      >=1.10

library
  build-depends:    $SELFDEP
  exposed-modules:
EOF

  echo "$CABAL"
}
#+END_SRC

**** A quick test
#+BEGIN_SRC sh :results output :exports none :noweb yes
<<mkDummyCabal>>
mkDummyCabal "foo-0.8.2"
#+END_SRC

#+RESULTS:
: cabal-version:      >=1.10
: 
: executable Dummy
:   build-depends:    foo ==0.8.2

*** Getting the file to build in a temporary directory
#+NAME: getCabalFile
#+BEGIN_SRC sh :noweb yes :exports code
<<mkDummyCabal>>

# If the argument is a cabal file, copy the contents of the directory
# it is in to the current directory. Otherwise, try using ~cabal get~
# to download the package from hackage.
getCabalFile() {
  if [ -f "$1" ]; then
    cp -R "$(dirname "$1")"/* .
  else
    mkdir -p .cabbages
    cabal get "$1" -d .cabbages
    local VERSIONED_NAME=$(ls .cabbages)
    mkDummyCabal "$VERSIONED_NAME" > dummy.cabal
  fi
}
#+END_SRC

** No arguments
This lets us just run the tangled shell script from the command line
and generates a Nix expression for the cabal file in the current
directory.

** Code
#+BEGIN_SRC sh :exports code :tangle cabbage :noweb yes
<<getCabalFile>>
<<defaultShell>>

showHelp() {
  echo "Usage: cabbage [-a] [-b] [packageName]"
  echo ""
  echo "- Run cabbage in a directory with a .cabal file to build Nix"
  echo "  expressions for the current package and all of its dependencies."
  echo "  Then run 'nix-shell --run 'sh $setup'' to ensure that all "
  echo "  dependencies are available in the Nix store, and to link them into "
  echo "  the sandbox. "
  echo "  If no sandbox is in the current directory, a new one will be created."
  echo ""
  echo "- The '-a' option will additionally link the dependencies of any "
  echo "  benchmark and test suites. "
  echo ""
  echo "- The '-b' option will build the project with nix-build."
  echo ""
  echo "- If cabbage is given a path to a .cabal file or a package name "
  echo "  (with optional version suffix) available on hackage, that package "
  echo "  will be built in a temporary directory so that it is available in "
  echo "  the Nix store for future builds. If you want executables provided "
  echo "  by that package to be linked into your environment, follow the "
  echo "  instructions in the last line of cabbage output."
}

ALLTARGETS=false

while getopts ":abh" opt; do
  case "$opt" in
    a) ALLTARGETS=true;;
    b) cabal configure && cabal sdist -v0 && nix-build shell.nix; exit 0;;
    h|\?) showHelp; exit 0;;
  esac
done
shift $((OPTIND - 1))

if [ "$#" -eq 0 ]; then
  if ! [ -f cabal.sandbox.config ]; then
    cabal sandbox init
  fi
  if ! [ -f shell.nix ]; then
    defaultShell > shell.nix
  fi
  mkCabbages $ALLTARGETS
else
  <<buildInTempDir>>
fi
#+END_SRC

* Tasks
** TODO Support a --dry-run option
It would be nice to get some sort of information about what you're
getting into before kicking off a big build.
** TODO Support a .cabbage dot file
This can be used to specify things that go into
~haskellBuildTools~. Specifically, the versions of GHC and
cabal-install.
** TODO Cache a hackage index file
We can extract the .cabal file for every needed package from the
index, and use that for nix file generation. However, the full index
file is 8.5MB, so we certainly /don't/ want to download it for every
cabbage run. However, having it cached locally would mean we could
generate nix files without any network activity.
** TODO Cache cabal freeze output
We can cache a ~cabal.config.bak~ file for a package. When looking
things up in the cache, if we find such a file, check the hackage
index for all dependencies to see if they have been modified since the
creation of the config file. If not, re-use the cached
file.

Dealing with add-source dependencies could be a bit tricky. We could
initially just not add such packages to the cache.

** TODO Cache cabbages
Right now, we always download a package and we always generate a
cabbage. What we could do is cache the downloaded source /and/ the
result of ~cabal freeze~, then do the cabal.config intersection and
check if we've got an equivalent default.nix in the cache. It's not
clear how much time this would save. We need to do the constraint
intersection no matter what. We could hash the constraint intersection
with the package's .cabal file and see if we've already generated an
equivalent cabbage. This would just save us the trouble of producing
the actual .nix files, but much of the work would have already been
done.
** TODO Produce a cabbage from a package's cabal file only
We can download just the ~.cabal~ file with something like,

#+BEGIN_SRC sh :exports none
curl http://hackage.haskell.org/package/lens-4.7/lens.cabal
#+END_SRC

and pipe that straight into cabbage production. Then, if we /need/ to
get the source, we can cabal get it. A downside to this is when it
comes to add-sourced dependencies. If we delay copying the source,
then we need to somehow remember how to get it. The current approach
gets the source right when we're working out from where to get the
~.cabal~ file for the dependency.
** TODO Loosen up constraint parsing
We might as well be a tiny bit flexible in parsing these lines.
** TODO Add source dependencies for add source dependencies
We can't run ~cabal freeze~ on an add-source dependency that depends
on another add-source dependency. We should be able to share the
downstream package's sandbox for that initial freeze. For subsequent,
isolated builds to be placed in the Nix store, we may need to take
care to prepare the sandbox before freezing.
** TODO systemDeps for common packages
We could define a Nix expression that has ~systemDeps~ for a bunch of
well-known Haskell packages. This could serve to obviate the need for
a ~cabbage.config~ specification of ~systemDeps~ for common
packages. Where would we install this package? If cabbage goes into
nixpkgs, then we could just install it alongside.
** TODO Automatic extra-libraries parsing
A Haskell package like ~zlib~ has an ~extra-libraries~ field that
mentions ~z~. This system dependency, ~libz~, is provided by the
nixpkgs package, ~zlib~. It would be nice to parse these out of .cabal
files automatically and map them to nixpkgs package names. In the
meantime, these can be manually specified a ~cabbage.config~ file.
